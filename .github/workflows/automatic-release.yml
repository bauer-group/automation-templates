name: üîÑ CI/CD Pipeline (Automatic Release)

# Main CI/CD pipeline using modular workflow components
# This demonstrates the new modular approach for this repository

on:
  push:
    branches: [main]
    paths-ignore:
      - '.github/**'
      - 'docs/**'
      - '*.md'
      - '*.MD'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      security-engine:
        description: 'Security scan engine'
        type: choice
        default: 'both'
        options: ['gitleaks', 'gitguardian', 'both']
      force-release:
        description: 'Force create release'
        type: boolean
        default: false
      artifact-types:
        description: 'Artifact types to generate'
        type: choice
        default: 'source'
        options: ['source', 'binaries', 'docker', 'all']

jobs:
  # PR validation for pull requests
  pr-validation:
    name: PR Quality Gate
    if: github.event_name == 'pull_request'
    uses: ./.github/workflows/modules-pr-validation.yml
    with:
      enable-security-scan: true
      enable-license-check: true
      enable-commit-lint: true
      security-scan-engine: 'gitleaks'
      fail-on-security-issues: true
      fail-on-license-issues: false
    secrets: inherit

  # Comprehensive security scan for main branch
  security-scan:
    name: Security Analysis
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
    uses: ./.github/workflows/modules-security-scan.yml
    with:
      scan-engine: ${{ inputs.security-engine || 'both' }}
      scan-type: 'all'
      fail-on-findings: false
      minimum-severity: 'medium'
    secrets: inherit

  # License compliance check
  license-compliance:
    name: License Compliance
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
    uses: ./.github/workflows/modules-license-compliance.yml
    with:
      fail-on-forbidden: false
      fail-on-unknown: false
      scan-dependencies: true
      generate-sbom: true
    secrets: inherit

  # Release management
  release-management:
    name: Release Management
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
    needs: [security-scan, license-compliance]
    uses: ./.github/workflows/modules-semantic-release.yml
    with:
      target-branch: 'main'
      dry-run: false
    secrets: inherit

  # Artifact generation for releases
  artifact-generation:
    name: Generate Artifacts
    if: needs.release-management.outputs.release-created == 'true'
    needs: release-management
    uses: ./.github/workflows/modules-artifact-generation.yml
    with:
      artifact-types: ${{ inputs.artifact-types || 'source' }}
      tag-name: ${{ needs.release-management.outputs.tag-name }}
      version: ${{ needs.release-management.outputs.version }}

  # Pipeline summary
  pipeline-summary:
    name: Pipeline Summary
    if: always() && ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch')
    needs: [security-scan, license-compliance, release-management, artifact-generation]
    runs-on: ubuntu-latest
    
    steps:
      - name: üìä Generate Pipeline Summary
        run: |
          echo "### üîÑ Modular CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** automation-templates" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Modular Workflow Components" >> $GITHUB_STEP_SUMMARY
          echo "**Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "| Module | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Security Scan** | ${{ needs.security-scan.result == 'success' && '‚úÖ PASS' || '‚ùå FAIL' }} | Score: ${{ needs.security-scan.outputs.security-score || 'N/A' }}/100 |" >> $GITHUB_STEP_SUMMARY
          echo "| **License Compliance** | ${{ needs.license-compliance.result == 'success' && '‚úÖ PASS' || '‚ùå FAIL' }} | Status: ${{ needs.license-compliance.outputs.compliance-status || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Management** | ${{ needs.release-management.result == 'success' && '‚úÖ PASS' || '‚ùå FAIL' }} | Created: ${{ needs.release-management.outputs.release-created || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Artifact Generation** | ${{ needs.artifact-generation.result == 'success' && '‚úÖ PASS' || needs.artifact-generation.result == 'skipped' && '‚è≠Ô∏è SKIP' || '‚ùå FAIL' }} | Generated: ${{ needs.artifact-generation.outputs.artifacts-generated || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.release-management.outputs.release-created }}" = "true" ]; then
            echo "üéâ **Release ${{ needs.release-management.outputs.version }} created successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Release Information:**" >> $GITHUB_STEP_SUMMARY
            echo "- Version: ${{ needs.release-management.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- Tag: ${{ needs.release-management.outputs.tag-name }}" >> $GITHUB_STEP_SUMMARY
            echo "- URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.release-management.outputs.tag-name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è **No release created.** Pipeline completed successfully." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Powered by **BAUER GROUP** modular workflow components* üß©" >> $GITHUB_STEP_SUMMARY

  # üìÑ Documentation Update (explicit call)
  # Explicitly trigger documentation updates after successful releases
  
  # Verify tag availability before documentation updates
  verify-tag-availability:
    name: Verify Tag Availability
    if: needs.release-management.outputs.release-created == 'true'
    needs: [release-management, artifact-generation]
    runs-on: ubuntu-latest
    outputs:
      tag-verified: ${{ steps.verify.outputs.tag-verified }}
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          fetch-tags: true

      - name: üîç Verify Tag Availability
        id: verify
        run: |
          TAG="${{ needs.release-management.outputs.tag-name }}"
          echo "üîç Verifying availability of tag: $TAG"
          
          # Retry logic for tag verification
          MAX_RETRIES=10  # 10 retries = 15 seconds max
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Fetch latest tags from remote
            git fetch --tags origin
            
            # Check if tag exists
            if git rev-parse "refs/tags/$TAG" >/dev/null 2>&1; then
              echo "‚úÖ Tag $TAG is available"
              echo "tag-verified=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Tag not yet available, attempt $RETRY_COUNT/$MAX_RETRIES"
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              # Progressive delay: 1s, 2s, 3s...
              DELAY=$RETRY_COUNT
              echo "‚è≥ Waiting ${DELAY}s before retry..."
              sleep $DELAY
            fi
          done
          
          echo "‚ùå Tag $TAG not available after $MAX_RETRIES attempts"
          echo "tag-verified=false" >> $GITHUB_OUTPUT
          exit 1

  # Step 1: Update documentation in the release tag
  update-documentation-in-tag:
    name: Update Documentation in Release Tag
    if: needs.release-management.outputs.release-created == 'true'
    needs: [verify-tag-availability]
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Release Tag
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ needs.release-management.outputs.tag-name }}

      - name: üìù Update Documentation in Tag
        uses: bauer-group/automation-templates/.github/actions/readme-generate@main
        with:
          template-path: 'docs/README.template.MD'
          output-path: 'README.MD'
          project-name: 'Automation Templates'
          company-name: 'BAUER GROUP'
          project-description: 'Professional automation templates and workflows with modular, reusable components for GitHub repositories'
          contact-email: 'support@bauer-group.com'
          documentation-url: 'https://github.com/bauer-group/automation-templates/wiki'
          support-url: 'https://github.com/bauer-group/automation-templates/issues'
          force-update: true
          custom-version: ${{ needs.release-management.outputs.version }}
          
      - name: üíæ Commit Documentation to Release Tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [[ -n $(git status --porcelain) ]]; then
            git add README.MD SECURITY.MD || true
            git commit -m "docs: update documentation for release ${{ needs.release-management.outputs.tag-name }}" || true
            
            # Force update the tag
            git tag -d ${{ needs.release-management.outputs.tag-name }} || true
            git tag ${{ needs.release-management.outputs.tag-name }}
            git push origin ${{ needs.release-management.outputs.tag-name }} --force
          fi

  # Step 2: Update documentation in main branch  
  update-documentation:
    name: Update Documentation in Main
    if: needs.release-management.outputs.release-created == 'true'
    needs: [update-documentation-in-tag]
    uses: ./.github/workflows/documentation.yml
    with:
      tag-name: ${{ needs.release-management.outputs.tag-name }}
      custom-version: ${{ needs.release-management.outputs.version }}
      force-update: true
    permissions:
      contents: write
      pull-requests: write

  # üõ°Ô∏è Security Management Update (explicit call)
  # Explicitly trigger security policy updates after successful releases

  # Step 1: Update security in the release tag
  update-security-in-tag:
    name: Update Security in Release Tag
    if: needs.release-management.outputs.release-created == 'true'
    needs: [update-documentation-in-tag]
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Release Tag
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ needs.release-management.outputs.tag-name }}

      - name: üõ°Ô∏è Update Security Policy in Tag
        uses: bauer-group/automation-templates/.github/actions/security-generate@main
        with:
          config-file: '.github/config/security-policy/config.yml'
          force-update: true
          custom-version: ${{ needs.release-management.outputs.version }}
          
      - name: üíæ Commit Security Policy to Release Tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [[ -n $(git status --porcelain) ]]; then
            git add SECURITY.MD || true
            git commit -m "security: update security policy for release ${{ needs.release-management.outputs.tag-name }}" || true
            
            # Force update the tag
            git tag -d ${{ needs.release-management.outputs.tag-name }} || true
            git tag ${{ needs.release-management.outputs.tag-name }}
            git push origin ${{ needs.release-management.outputs.tag-name }} --force
          fi

  # Step 2: Update security in main branch
  update-security-management:
    name: Update Security Management in Main
    if: needs.release-management.outputs.release-created == 'true'
    needs: [update-security-in-tag]
    uses: ./.github/workflows/security-management.yml
    with:
      tag-name: ${{ needs.release-management.outputs.tag-name }}
      custom-version: ${{ needs.release-management.outputs.version }}
      force-update: true
    permissions:
      contents: write
      pull-requests: write

  # Sync CHANGELOG from release tag to main branch
  sync-changelog:
    name: Sync CHANGELOG to Main Branch
    if: needs.release-management.outputs.release-created == 'true'
    needs: [release-management]
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Main Branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          fetch-tags: true
          ref: main

      - name: üìù Extract CHANGELOG from Release
        run: |
          TAG="${{ needs.release-management.outputs.tag-name }}"
          VERSION="${{ needs.release-management.outputs.version }}"
          
          echo "üìù Extracting changelog from release $TAG"
          
          # Get release notes from GitHub API
          RELEASE_NOTES=$(gh release view "$TAG" --json body --jq '.body' 2>/dev/null || echo "")
          
          if [ -z "$RELEASE_NOTES" ]; then
            echo "‚ö†Ô∏è No release notes found for $TAG"
            exit 0
          fi
          
          # Check if CHANGELOG already contains this version
          if grep -q "## \[${VERSION}\]" CHANGELOG.MD 2>/dev/null; then
            echo "‚ÑπÔ∏è CHANGELOG already contains version ${VERSION}"
            exit 0
          fi
          
          echo "üìù Adding version ${VERSION} to CHANGELOG"
          
          # Create temporary file with new changelog entry
          echo "$RELEASE_NOTES" > temp_new_entry.md
          echo "" >> temp_new_entry.md
          
          # Prepend new entry to existing CHANGELOG
          if [ -f "CHANGELOG.MD" ]; then
            cat CHANGELOG.MD >> temp_new_entry.md
          fi
          
          mv temp_new_entry.md CHANGELOG.MD
          
          echo "‚úÖ CHANGELOG updated with release $TAG"

      - name: üíæ Commit CHANGELOG Updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "üìã CHANGELOG Sync"
          
          if [[ -n $(git status --porcelain CHANGELOG.MD) ]]; then
            git add CHANGELOG.MD
            git commit -m "docs: sync CHANGELOG from release ${{ needs.release-management.outputs.tag-name }}"
            git push origin main
            echo "‚úÖ CHANGELOG synchronized to main branch"
          else
            echo "‚ÑπÔ∏è No CHANGELOG changes to commit"
          fi
  