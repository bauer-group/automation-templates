name: ğŸ Python Build & Test

on:
  workflow_call:
    inputs:
      # Python Configuration
      python-version:
        description: 'Python version(s) - comma-separated for multiple'
        type: string
        required: false
        default: '3.12'
      
      python-version-file:
        description: 'Path to .python-version or pyproject.toml file'
        type: string
        required: false
        default: ''
      
      # Project Configuration
      working-directory:
        description: 'Working directory for all commands'
        type: string
        required: false
        default: '.'
      
      package-source-path:
        description: 'Path to package source code (for legacy projects)'
        type: string
        required: false
        default: ''
      
      project-type:
        description: 'Project type (app, package, web-app, data-science, microservice)'
        type: string
        required: false
        default: 'app'
      
      # Dependencies
      requirements-files:
        description: 'Requirements files as JSON array'
        type: string
        required: false
        default: '["requirements.txt"]'
      
      install-dev-requirements:
        description: 'Install development requirements'
        type: boolean
        required: false
        default: true
      
      install-command:
        description: 'Custom install command'
        type: string
        required: false
        default: ''
      
      upgrade-pip:
        description: 'Upgrade pip before installation'
        type: boolean
        required: false
        default: true
      
      # Virtual Environment
      use-venv:
        description: 'Create and use virtual environment'
        type: boolean
        required: false
        default: false
      
      # Package Management
      package-manager:
        description: 'Package manager (pip, poetry, pipenv, conda)'
        type: string
        required: false
        default: 'pip'
      
      cache-dependencies:
        description: 'Cache dependencies'
        type: boolean
        required: false
        default: true
      
      # Testing Configuration
      run-tests:
        description: 'Run tests'
        type: boolean
        required: false
        default: true
      
      test-framework:
        description: 'Test framework (pytest, unittest, nose2)'
        type: string
        required: false
        default: 'pytest'
      
      test-command:
        description: 'Custom test command'
        type: string
        required: false
        default: ''
      
      test-path:
        description: 'Path to tests'
        type: string
        required: false
        default: 'tests'
      
      test-args:
        description: 'Additional test arguments'
        type: string
        required: false
        default: ''
      
      # Coverage
      collect-coverage:
        description: 'Collect test coverage'
        type: boolean
        required: false
        default: true
      
      coverage-threshold:
        description: 'Minimum coverage threshold percentage'
        type: number
        required: false
        default: 80
      
      coverage-format:
        description: 'Coverage report format (xml, html, term)'
        type: string
        required: false
        default: 'xml'
      
      coverage-fail-under:
        description: 'Fail if coverage is under threshold'
        type: boolean
        required: false
        default: false
      
      # Code Quality
      run-lint:
        description: 'Run linting'
        type: boolean
        required: false
        default: true
      
      linter:
        description: 'Linter to use (flake8, ruff, pylint)'
        type: string
        required: false
        default: 'flake8'
      
      lint-config:
        description: 'Path to lint configuration file'
        type: string
        required: false
        default: ''
      
      max-line-length:
        description: 'Maximum line length for linting'
        type: number
        required: false
        default: 88
      
      # Code Formatting
      run-format-check:
        description: 'Check code formatting'
        type: boolean
        required: false
        default: false
      
      formatter:
        description: 'Code formatter (black, autopep8, yapf)'
        type: string
        required: false
        default: 'black'
      
      format-check-only:
        description: 'Only check formatting, dont fix'
        type: boolean
        required: false
        default: true
      
      # Import Sorting
      run-isort-check:
        description: 'Check import sorting'
        type: boolean
        required: false
        default: false
      
      isort-check-only:
        description: 'Only check import sorting, dont fix'
        type: boolean
        required: false
        default: true
      
      # Type Checking
      run-type-check:
        description: 'Run type checking'
        type: boolean
        required: false
        default: false
      
      type-checker:
        description: 'Type checker (mypy, pyright, pyre)'
        type: string
        required: false
        default: 'mypy'
      
      type-check-args:
        description: 'Additional type check arguments'
        type: string
        required: false
        default: '--ignore-missing-imports'
      
      # Security Scanning
      run-security-scan:
        description: 'Run security scanning'
        type: boolean
        required: false
        default: true
      
      security-tools:
        description: 'Security tools as JSON array (bandit, pip-audit)'
        type: string
        required: false
        default: '["bandit", "pip-audit"]'
      
      security-fail-on-error:
        description: 'Fail build on security issues'
        type: boolean
        required: false
        default: false
      
      # Build & Package
      build-package:
        description: 'Build package (wheel/sdist)'
        type: boolean
        required: false
        default: false
      
      build-tools:
        description: 'Build tools as JSON array'
        type: string
        required: false
        default: '["build", "twine"]'
      
      package-check:
        description: 'Check package with twine'
        type: boolean
        required: false
        default: true
      
      # Matrix Configuration
      enable-matrix:
        description: 'Enable matrix builds'
        type: boolean
        required: false
        default: false
      
      matrix-os:
        description: 'OS matrix as JSON array'
        type: string
        required: false
        default: '["ubuntu-latest"]'
      
      matrix-python:
        description: 'Python version matrix as JSON array'
        type: string
        required: false
        default: '["3.12"]'
      
      matrix-fail-fast:
        description: 'Fail fast in matrix builds'
        type: boolean
        required: false
        default: false
      
      # Platform Configuration
      runs-on:
        description: 'Runner to use. Use string for GitHub-hosted (e.g., "ubuntu-latest") or JSON array for self-hosted (e.g., ["self-hosted", "linux"])'
        type: string
        required: false
        default: 'ubuntu-latest'
      
      timeout-minutes:
        description: 'Job timeout in minutes'
        type: number
        required: false
        default: 30
      
      # Artifact Management
      upload-artifacts:
        description: 'Upload build artifacts'
        type: boolean
        required: false
        default: true
      
      artifact-name:
        description: 'Name for uploaded artifacts'
        type: string
        required: false
        default: 'python-build'
      
      artifact-paths:
        description: 'Artifact paths as JSON array'
        type: string
        required: false
        default: '[]'
      
      artifact-retention-days:
        description: 'Number of days to retain artifacts'
        type: number
        required: false
        default: 30
      
    secrets:
      CODECOV_TOKEN:
        description: 'Codecov token for uploading coverage reports'
        required: false
      
      SONARCLOUD_TOKEN:
        description: 'SonarCloud token for code quality analysis'
        required: false
      
      PYPI_API_TOKEN:
        description: 'PyPI API token for package publishing'
        required: false
      
      TEST_PYPI_API_TOKEN:
        description: 'TestPyPI API token for package publishing'
        required: false
    
    outputs:
      python-version:
        description: 'Python version used'
        value: ${{ jobs.build.outputs.python-version }}
      
      package-version:
        description: 'Package version'
        value: ${{ jobs.build.outputs.package-version }}
      
      test-results:
        description: 'Test results status'
        value: ${{ jobs.build.outputs.test-results }}
      
      coverage-percentage:
        description: 'Coverage percentage'
        value: ${{ jobs.build.outputs.coverage-percentage }}
      
      package-path:
        description: 'Path to built package'
        value: ${{ jobs.build.outputs.package-path }}

jobs:
  build:
    name: Python Build
    runs-on: ${{ inputs.enable-matrix && matrix.os || (startsWith(inputs.runs-on, '[') && fromJSON(inputs.runs-on) || inputs.runs-on) }}
    timeout-minutes: ${{ inputs.timeout-minutes }}
    
    strategy:
      matrix:
        os: ${{ inputs.enable-matrix && fromJson(inputs.matrix-os) || fromJson('["ubuntu-latest"]') }}
        python-version: ${{ inputs.enable-matrix && fromJson(inputs.matrix-python) || fromJson('["3.12"]') }}
      fail-fast: ${{ inputs.matrix-fail-fast }}
    
    outputs:
      python-version: ${{ steps.setup-python.outputs.python-version }}
      package-version: ${{ steps.version.outputs.version }}
      test-results: ${{ steps.test.outputs.results }}
      coverage-percentage: ${{ steps.coverage.outputs.percentage }}
      package-path: ${{ steps.package.outputs.path }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          lfs: true
      
      - name: ğŸ Setup Python
        id: setup-python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.enable-matrix && matrix.python-version || inputs.python-version }}
          python-version-file: ${{ inputs.python-version-file }}
          cache: ${{ inputs.package-manager == 'pip' && inputs.cache-dependencies && 'pip' || '' }}
          cache-dependency-path: |
            requirements*.txt
            pyproject.toml
            poetry.lock
            Pipfile.lock
      
      - name: ğŸ”§ Setup Package Manager
        shell: bash
        run: |
          if [ "${{ inputs.package-manager }}" = "poetry" ]; then
            curl -sSL https://install.python-poetry.org | python3 -
            echo "$HOME/.local/bin" >> $GITHUB_PATH
          elif [ "${{ inputs.package-manager }}" = "pipenv" ]; then
            pip install pipenv
          fi
      
      - name: ğŸ“¦ Cache Dependencies
        if: inputs.cache-dependencies && inputs.package-manager != 'pip'
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pypoetry
            ~/.local/share/virtualenvs
            ~/.cache/pipenv
          key: ${{ inputs.package-manager }}-${{ runner.os }}-${{ inputs.enable-matrix && matrix.python-version || inputs.python-version }}-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml', '**/poetry.lock', '**/Pipfile.lock') }}
          restore-keys: |
            ${{ inputs.package-manager }}-${{ runner.os }}-${{ inputs.enable-matrix && matrix.python-version || inputs.python-version }}-
            ${{ inputs.package-manager }}-${{ runner.os }}-
      
      - name: ğŸ·ï¸ Determine Version
        id: version
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ -f "pyproject.toml" ] && command -v python3 >/dev/null; then
            VERSION=$(python3 -c "try: import tomllib; except ImportError: import tomli as tomllib; config = tomllib.load(open('pyproject.toml', 'rb')); print(config['project']['version'])" 2>/dev/null || echo "")
          fi
          
          if [ -z "$VERSION" ] && [ -f "setup.py" ]; then
            VERSION=$(python3 setup.py --version 2>/dev/null || echo "")
          fi
          
          if [ -z "$VERSION" ]; then
            VERSION="0.1.0-dev.${{ github.run_number }}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Package version: $VERSION"
      
      - name: ğŸ”§ Create Virtual Environment
        if: inputs.use-venv && inputs.package-manager == 'pip'
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          python -m venv venv
          if [ "$RUNNER_OS" = "Windows" ]; then
            echo "$(pwd)/venv/Scripts" >> $GITHUB_PATH
            echo "VIRTUAL_ENV=$(pwd)/venv" >> $GITHUB_ENV
          else
            echo "$(pwd)/venv/bin" >> $GITHUB_PATH
            echo "VIRTUAL_ENV=$(pwd)/venv" >> $GITHUB_ENV
          fi
      
      - name: â¬†ï¸ Upgrade pip
        if: inputs.upgrade-pip
        run: python -m pip install --upgrade pip
      
      - name: ğŸ“š Install Dependencies
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ -n "${{ inputs.install-command }}" ]; then
            eval "${{ inputs.install-command }}"
          elif [ "${{ inputs.package-manager }}" = "poetry" ]; then
            poetry install
          elif [ "${{ inputs.package-manager }}" = "pipenv" ]; then
            pipenv install --dev
          else
            # Modern pyproject.toml-based project
            if [ -f "pyproject.toml" ]; then
              echo "ğŸ”§ Detected pyproject.toml - using modern Python packaging"
              
              # Check if project has dependencies defined in pyproject.toml
              if python3 -c "try: import tomllib; except ImportError: import tomli as tomllib; config = tomllib.load(open('pyproject.toml', 'rb')); exit(0 if 'dependencies' in config.get('project', {}) else 1)" 2>/dev/null; then
                echo "ğŸ“¦ Installing dependencies from pyproject.toml"
                pip install -e .
              else
                echo "âš ï¸ No dependencies found in pyproject.toml, trying requirements files"
                # Fallback to requirements files if pyproject.toml has no dependencies
                REQUIREMENTS_FILES='${{ inputs.requirements-files }}'
                echo "$REQUIREMENTS_FILES" | jq -r '.[]' | while read -r file; do
                  if [ -f "$file" ]; then
                    echo "Installing from $file"
                    pip install -r "$file"
                  fi
                done
                # Still install the package itself
                pip install -e .
              fi
              
              # Install optional dev dependencies from pyproject.toml
              if [ "${{ inputs.install-dev-requirements }}" = "true" ]; then
                if python3 -c "try: import tomllib; except ImportError: import tomli as tomllib; config = tomllib.load(open('pyproject.toml', 'rb')); exit(0 if 'optional-dependencies' in config.get('project', {}) else 1)" 2>/dev/null; then
                  echo "ğŸ”§ Installing optional dev dependencies from pyproject.toml"
                  pip install -e ".[dev]" 2>/dev/null || pip install -e ".[development]" 2>/dev/null || echo "âš ï¸ No [dev] or [development] optional dependencies found"
                fi
              fi
              
            # Legacy setup.py-based project  
            elif [ -f "setup.py" ]; then
              echo "ğŸ”§ Detected setup.py - using legacy Python packaging"
              
              # Install from requirements files first
              REQUIREMENTS_FILES='${{ inputs.requirements-files }}'
              echo "$REQUIREMENTS_FILES" | jq -r '.[]' | while read -r file; do
                if [ -f "$file" ]; then
                  echo "Installing from $file"
                  pip install -r "$file"
                fi
              done
              
              if [ "${{ inputs.install-dev-requirements }}" = "true" ] && [ -f "requirements-dev.txt" ]; then
                pip install -r requirements-dev.txt
              fi
              
              # Install package in development mode
              pip install -e .
              
            # Requirements-only project (no package)
            else
              echo "ğŸ“¦ Installing from requirements files only"
              REQUIREMENTS_FILES='${{ inputs.requirements-files }}'
              echo "$REQUIREMENTS_FILES" | jq -r '.[]' | while read -r file; do
                if [ -f "$file" ]; then
                  echo "Installing from $file"
                  pip install -r "$file"
                fi
              done
              
              if [ "${{ inputs.install-dev-requirements }}" = "true" ] && [ -f "requirements-dev.txt" ]; then
                pip install -r requirements-dev.txt
              fi
            fi
          fi
      
      - name: ğŸ“¦ Install Build Tools
        if: inputs.build-package
        shell: bash
        run: |
          BUILD_TOOLS='${{ inputs.build-tools }}'
          echo "$BUILD_TOOLS" | jq -r '.[]' | while read -r tool; do
            pip install "$tool"
          done
      
      - name: ğŸ” Run Security Scan
        if: inputs.run-security-scan
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        continue-on-error: ${{ !inputs.security-fail-on-error }}
        run: |
          SECURITY_TOOLS='${{ inputs.security-tools }}'
          
          if echo "$SECURITY_TOOLS" | jq -e '. | index("pip-audit")' >/dev/null; then
            pip install pip-audit
            echo "Running pip-audit vulnerability check..."
            pip-audit --format=json --output=pip-audit-report.json || echo "âš ï¸ Vulnerability scan completed with warnings"
          fi
          
          if echo "$SECURITY_TOOLS" | jq -e '. | index("bandit")' >/dev/null; then
            pip install bandit
            echo "Running bandit security scan..."
            bandit -r . -f json -o bandit-report.json || true
          fi
      
      - name: ğŸ§¹ Run Linting
        if: inputs.run-lint
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ "${{ inputs.linter }}" = "ruff" ]; then
            pip install ruff
            ruff check . --output-format=json --output-file=ruff-report.json || true
          elif [ "${{ inputs.linter }}" = "pylint" ]; then
            pip install pylint
            pylint --output-format=json --reports=no $(find . -name "*.py") > pylint-report.json || true
          else
            # Default: flake8
            pip install flake8
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
            flake8 . --count --exit-zero --max-complexity=10 --max-line-length=${{ inputs.max-line-length }} --statistics --format=json --output-file=flake8-report.json
          fi
      
      - name: ğŸ¨ Check Code Formatting
        if: inputs.run-format-check
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ "${{ inputs.formatter }}" = "black" ]; then
            pip install black
            if [ "${{ inputs.format-check-only }}" = "true" ]; then
              black --check --diff .
            else
              black .
            fi
          elif [ "${{ inputs.formatter }}" = "autopep8" ]; then
            pip install autopep8
            if [ "${{ inputs.format-check-only }}" = "true" ]; then
              autopep8 --diff --recursive .
            else
              autopep8 --in-place --recursive .
            fi
          fi
      
      - name: ğŸ“¤ Check Import Sorting
        if: inputs.run-isort-check
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          pip install isort
          if [ "${{ inputs.isort-check-only }}" = "true" ]; then
            isort --check-only --diff .
          else
            isort .
          fi
      
      - name: ğŸ”¤ Run Type Checking
        if: inputs.run-type-check
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        continue-on-error: true
        run: |
          if [ "${{ inputs.type-checker }}" = "mypy" ]; then
            pip install mypy
            mypy . ${{ inputs.type-check-args }}
          elif [ "${{ inputs.type-checker }}" = "pyright" ]; then
            npm install -g pyright
            pyright .
          fi
      
      - name: ğŸ§ª Run Tests
        id: test
        if: inputs.run-tests
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          TEST_RESULTS_DIR="${{ runner.temp }}/test-results"
          mkdir -p "$TEST_RESULTS_DIR"
          
          if [ -n "${{ inputs.test-command }}" ]; then
            eval "${{ inputs.test-command }}"
          elif [ "${{ inputs.test-framework }}" = "pytest" ]; then
            # Intelligente Test-Pfad-Erkennung
            TEST_PATH=""
            
            # 1. Expliziter test-path Parameter
            if [ -n "${{ inputs.test-path }}" ] && [ "${{ inputs.test-path }}" != "tests" ]; then
              if [ -d "${{ inputs.test-path }}" ] || [ -f "${{ inputs.test-path }}" ]; then
                TEST_PATH="${{ inputs.test-path }}"
              fi
            fi
            
            # 2. pyproject.toml testpaths
            if [ -z "$TEST_PATH" ] && [ -f "pyproject.toml" ]; then
              TEMP_FILE="/tmp/testpath_${{ github.run_id }}_$$"
              python3 -c "import sys; exec('try: import tomllib\\nexcept ImportError: import tomli as tomllib\\ntry:\\n  with open(\\"pyproject.toml\\", \\"rb\\") as f: config = tomllib.load(f)\\n  testpaths = config.get(\\"tool\\", {}).get(\\"pytest\\", {}).get(\\"ini_options\\", {}).get(\\"testpaths\\", [])\\n  if testpaths and isinstance(testpaths, list) and len(testpaths) > 0: print(testpaths[0])\\n  elif testpaths and isinstance(testpaths, str): print(testpaths.strip())\\nexcept: pass')" 2>/dev/null > "$TEMP_FILE" || true
              if [ -s "$TEMP_FILE" ]; then
                TEST_PATH=$(cat "$TEMP_FILE")
                rm -f "$TEMP_FILE"
              fi
            fi
            
            # 3. Standard-Pfade
            if [ -z "$TEST_PATH" ]; then
              for path in "tests" "test"; do
                if [ -d "$path" ]; then
                  TEST_PATH="$path"
                  break
                fi
              done
            fi
            
            # 4. Package-source-path Tests
            if [ -z "$TEST_PATH" ] && [ -n "${{ inputs.package-source-path }}" ]; then
              for path in "${{ inputs.package-source-path }}/tests" "${{ inputs.package-source-path }}/test"; do
                if [ -d "$path" ]; then
                  TEST_PATH="$path"
                  break
                fi
              done
            fi
            
            # 5. Fallback: Test-Struktur erstellen
            if [ -z "$TEST_PATH" ]; then
              echo "âš ï¸ No test directory found - creating minimal test structure"
              mkdir -p tests
              echo 'def test_placeholder(): assert True' > tests/test_placeholder.py
              TEST_PATH="tests"
            fi
            
            echo "ğŸ” Test path detected: $TEST_PATH"
            
            # Install base testing dependencies
            pip install pytest pytest-xdist
            
            # Install tomli for Python <3.11 compatibility  
            python3 -c "import sys; sys.exit(0 if sys.version_info >= (3,11) else 1)" || pip install tomli
            
            if [ "${{ inputs.collect-coverage }}" = "true" ]; then
              # Install coverage dependencies
              pip install pytest-cov coverage[toml]
              
              # Intelligente Coverage-Source-Erkennung
              COVERAGE_SOURCE=""
              
              # 1. pyproject.toml coverage.run.source
              if [ -f "pyproject.toml" ]; then
                TEMP_FILE="/tmp/coverage_source_${{ github.run_id }}_$$"
                python3 -c "import sys; exec('try: import tomllib\\nexcept ImportError: import tomli as tomllib\\ntry:\\n  with open(\\"pyproject.toml\\", \\"rb\\") as f: config = tomllib.load(f)\\n  sources = config.get(\\"tool\\", {}).get(\\"coverage\\", {}).get(\\"run\\", {}).get(\\"source\\", [])\\n  if sources and isinstance(sources, list) and len(sources) > 0: print(sources[0])\\n  elif sources and isinstance(sources, str): print(sources.strip())\\nexcept: pass')" 2>/dev/null > "$TEMP_FILE" || true
                if [ -s "$TEMP_FILE" ]; then
                  COVERAGE_SOURCE=$(cat "$TEMP_FILE")
                  rm -f "$TEMP_FILE"
                fi
              fi
              
              # 2. Expliziter package-source-path
              if [ -z "$COVERAGE_SOURCE" ] && [ -n "${{ inputs.package-source-path }}" ]; then
                if [ -d "${{ inputs.package-source-path }}" ]; then
                  COVERAGE_SOURCE="${{ inputs.package-source-path }}"
                fi
              fi
              
              # 3. Fallback
              if [ -z "$COVERAGE_SOURCE" ]; then
                COVERAGE_SOURCE="."
              fi
              
              COVERAGE_ARGS="--cov=$COVERAGE_SOURCE --cov-report=${{ inputs.coverage-format }}"
              if [ "${{ inputs.coverage-fail-under }}" = "true" ]; then
                COVERAGE_ARGS="$COVERAGE_ARGS --cov-fail-under=${{ inputs.coverage-threshold }}"
              fi
              
              echo "ğŸ” Coverage source detected: $COVERAGE_SOURCE"
              
              # For pytest-xdist compatibility, we need special handling
              # First try with distributed execution and coverage
              echo "ğŸ§ª Running tests with coverage and distributed execution..."
              
              pytest "$TEST_PATH" \
                --junitxml="$TEST_RESULTS_DIR/pytest-report.xml" \
                -n auto \
                $COVERAGE_ARGS \
                ${{ inputs.test-args }} \
                --tb=short \
                --disable-warnings || {
                
                # If that fails, try without distributed execution
                echo "âš ï¸ Distributed execution with coverage failed, trying sequential execution..."
                
                pytest "$TEST_PATH" \
                  --junitxml="$TEST_RESULTS_DIR/pytest-report.xml" \
                  $COVERAGE_ARGS \
                  ${{ inputs.test-args }} \
                  --tb=short \
                  --disable-warnings || {
                  
                  # Final fallback: run without coverage
                  echo "âš ï¸ Coverage collection failed, running tests without coverage..."
                  
                  pytest "$TEST_PATH" \
                    --junitxml="$TEST_RESULTS_DIR/pytest-report.xml" \
                    ${{ inputs.test-args }} \
                    --tb=short \
                    --disable-warnings
                }
              }
            else
              # No coverage collection
              echo "ğŸ§ª Running tests without coverage collection..."
              
              pytest "$TEST_PATH" \
                --junitxml="$TEST_RESULTS_DIR/pytest-report.xml" \
                -n auto \
                ${{ inputs.test-args }} \
                --tb=short \
                --disable-warnings || {
                
                # Fallback without distributed execution
                echo "âš ï¸ Distributed execution failed, trying sequential execution..."
                
                pytest "$TEST_PATH" \
                  --junitxml="$TEST_RESULTS_DIR/pytest-report.xml" \
                  ${{ inputs.test-args }} \
                  --tb=short \
                  --disable-warnings
              }
            fi
          elif [ "${{ inputs.test-framework }}" = "unittest" ]; then
            pip install xmlrunner
            python -c "import sys, os, unittest, xmlrunner; sys.path.insert(0, '${{ inputs.test-path }}'); loader = unittest.TestLoader(); suite = loader.discover('${{ inputs.test-path }}', pattern='test*.py'); output = open('\$TEST_RESULTS_DIR/unittest-report.xml', 'wb'); runner = xmlrunner.XMLTestRunner(output=output); result = runner.run(suite); output.close(); sys.exit(0 if result.wasSuccessful() else 1)"
          fi
          
          echo "results=success" >> $GITHUB_OUTPUT
      
      - name: ğŸ“Š Process Coverage
        id: coverage
        if: inputs.collect-coverage
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ -f "coverage.xml" ]; then
            # Extract coverage percentage (simplified)
            COVERAGE_PCT=$(grep -o 'line-rate="[0-9.]*"' coverage.xml | head -1 | grep -o '[0-9.]*' | awk '{print $1*100}')
            echo "percentage=$COVERAGE_PCT" >> $GITHUB_OUTPUT
            echo "Coverage: $COVERAGE_PCT%"
          fi
      
      - name: ğŸ“Š Upload Coverage to Codecov
        if: inputs.collect-coverage == 'true'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ${{ inputs.working-directory }}/coverage.xml
          flags: unittests
          fail_ci_if_error: false
      
      - name: ğŸ“¦ Build Package
        id: package
        if: inputs.build-package
        shell: bash
        run: |
          PACKAGE_OUTPUT_DIR="${{ runner.temp }}/packages"
          mkdir -p "$PACKAGE_OUTPUT_DIR"
          
          # pyproject.toml und setup.py sind Ã¼blicherweise im Repository-Root
          # Daher immer vom Root aus bauen, nicht vom working-directory
          
          if [ "${{ inputs.package-manager }}" = "poetry" ]; then
            poetry build
            cp dist/* "$PACKAGE_OUTPUT_DIR/"
          else
            # Standard Python build - lÃ¤uft vom Repository-Root
            python -m build --outdir "$PACKAGE_OUTPUT_DIR"
          fi
          
          if [ "${{ inputs.package-check }}" = "true" ]; then
            twine check "$PACKAGE_OUTPUT_DIR"/*
          fi
          
          PACKAGE_FILE=$(find "$PACKAGE_OUTPUT_DIR" -name "*.whl" -type f | head -1)
          echo "path=$PACKAGE_FILE" >> $GITHUB_OUTPUT
          echo "Package built: $PACKAGE_FILE"
      
      - name: ğŸ“Š Check Test Report Files
        id: check-reports
        if: always() && inputs.run-tests
        shell: bash
        run: |
          if ls ${{ runner.temp }}/test-results/*.xml 1> /dev/null 2>&1; then
            echo "reports-exist=true" >> $GITHUB_OUTPUT
            echo "âœ… Test report files found"
          else
            echo "reports-exist=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ No test report files found"
          fi

      - name: ğŸ“Š Test Report
        if: always() && inputs.run-tests && steps.check-reports.outputs.reports-exist == 'true'
        uses: dorny/test-reporter@v2
        with:
          name: 'Python Tests - ${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}'
          path: '${{ runner.temp }}/test-results/*.xml'
          reporter: 'java-junit'
          fail-on-error: false
      
      - name: ğŸ“¤ Upload Test Artifacts
        if: always() && inputs.upload-artifacts && inputs.run-tests
        uses: actions/upload-artifact@v6
        with:
          name: test-results-${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}-${{ inputs.enable-matrix && matrix.python-version || inputs.python-version }}
          path: |
            ${{ runner.temp }}/test-results/
            ${{ inputs.working-directory }}/htmlcov/
            ${{ inputs.working-directory }}/*-report.json
          retention-days: ${{ inputs.artifact-retention-days }}
      
      - name: ğŸ“¤ Upload Package Artifacts
        if: inputs.upload-artifacts && inputs.build-package
        uses: actions/upload-artifact@v6
        with:
          name: python-packages-${{ steps.version.outputs.version }}
          path: ${{ runner.temp }}/packages/
          retention-days: ${{ inputs.artifact-retention-days }}
      
      - name: ğŸ“¤ Upload Custom Artifacts
        if: inputs.upload-artifacts && inputs.artifact-paths != '[]'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ inputs.artifact-name }}-${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}
          path: |
            ${{ join(fromJson(inputs.artifact-paths), '\n') }}
          retention-days: ${{ inputs.artifact-retention-days }}