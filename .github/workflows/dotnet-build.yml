name: ğŸš€ .NET Build

on:
  workflow_call:
    inputs:
      # .NET Configuration
      dotnet-version:
        description: '.NET SDK version(s) to use (comma-separated for multiple)'
        type: string
        required: false
        default: '8.0.x'
      
      global-json-file:
        description: 'Path to global.json for SDK version'
        type: string
        required: false
        default: ''
      
      dotnet-quality:
        description: 'Quality of .NET SDK (daily, signed, validated, preview, ga)'
        type: string
        required: false
        default: ''
      
      # Project Configuration
      project-path:
        description: 'Path to project file(s) or solution'
        type: string
        required: false
        default: '.'
      
      working-directory:
        description: 'Working directory for all commands'
        type: string
        required: false
        default: '.'
      
      configuration:
        description: 'Build configuration (Debug, Release)'
        type: string
        required: false
        default: 'Release'
      
      # Build Options
      build-args:
        description: 'Additional arguments for dotnet build'
        type: string
        required: false
        default: ''

      # Assembly Signing
      snk-file-path:
        description: 'Path where SNK key should be created (relative to working-directory). Must match AssemblyOriginatorKeyFile in csproj/Directory.Build.props. Example: build/MyProject.snk'
        type: string
        required: false
        default: ''

      restore-args:
        description: 'Additional arguments for dotnet restore'
        type: string
        required: false
        default: ''
      
      verbosity:
        description: 'Logging verbosity (quiet, minimal, normal, detailed, diagnostic)'
        type: string
        required: false
        default: 'normal'
      
      treat-warnings-as-errors:
        description: 'Treat warnings as errors'
        type: boolean
        required: false
        default: false
      
      # Runtime Configuration
      runtime:
        description: 'Target runtime (e.g., linux-x64, win-x64, osx-x64)'
        type: string
        required: false
        default: ''
      
      self-contained:
        description: 'Create self-contained deployment'
        type: boolean
        required: false
        default: false
      
      # Testing Configuration
      run-tests:
        description: 'Run unit tests'
        type: boolean
        required: false
        default: true
      
      test-filter:
        description: 'Test filter expression'
        type: string
        required: false
        default: ''
      
      test-args:
        description: 'Additional arguments for dotnet test'
        type: string
        required: false
        default: ''
      
      test-logger:
        description: 'Test logger to use (trx, html, console)'
        type: string
        required: false
        default: 'trx;LogFileName=test-results.trx'
      
      # Code Coverage
      collect-coverage:
        description: 'Collect code coverage'
        type: boolean
        required: false
        default: false
      
      coverage-type:
        description: 'Coverage format (cobertura, opencover, coverlet)'
        type: string
        required: false
        default: 'cobertura'
      
      coverage-threshold:
        description: 'Minimum coverage threshold percentage'
        type: number
        required: false
        default: 0
      
      coverage-exclude:
        description: 'Namespaces/files to exclude from coverage (comma-separated)'
        type: string
        required: false
        default: ''
      
      # Code Analysis
      run-code-analysis:
        description: 'Run code analysis'
        type: boolean
        required: false
        default: false
      
      analysis-level:
        description: 'Analysis level (none, default, minimum, recommended, all)'
        type: string
        required: false
        default: 'recommended'
      
      # Publishing Options
      publish:
        description: 'Publish the application'
        type: boolean
        required: false
        default: false
      
      publish-args:
        description: 'Additional arguments for dotnet publish'
        type: string
        required: false
        default: ''
      
      output-directory:
        description: 'Output directory for publish'
        type: string
        required: false
        default: './publish'
      
      # Package Management
      create-package:
        description: 'Create NuGet package'
        type: boolean
        required: false
        default: false
      
      package-version:
        description: 'Package version (leave empty for auto)'
        type: string
        required: false
        default: ''
      
      include-symbols:
        description: 'Include symbols in package'
        type: boolean
        required: false
        default: true
      
      include-source:
        description: 'Include source in package'
        type: boolean
        required: false
        default: false
      
      # Push to NuGet
      push-to-nuget:
        description: 'Push package to NuGet'
        type: boolean
        required: false
        default: false
      
      nuget-source:
        description: 'NuGet source URL'
        type: string
        required: false
        default: 'https://api.nuget.org/v3/index.json'
      
      # Docker Support
      build-docker:
        description: 'Build Docker image'
        type: boolean
        required: false
        default: false
      
      dockerfile-path:
        description: 'Path to Dockerfile'
        type: string
        required: false
        default: './Dockerfile'
      
      docker-image-name:
        description: 'Docker image name'
        type: string
        required: false
        default: ''
      
      docker-registry:
        description: 'Docker registry URL'
        type: string
        required: false
        default: ''
      
      # Artifact Management
      upload-artifacts:
        description: 'Upload build artifacts'
        type: boolean
        required: false
        default: true
      
      artifact-name:
        description: 'Name for uploaded artifacts'
        type: string
        required: false
        default: 'dotnet-build'
      
      artifact-path:
        description: 'Path pattern for artifacts'
        type: string
        required: false
        default: ''
      
      artifact-retention-days:
        description: 'Number of days to retain artifacts'
        type: number
        required: false
        default: 30
      
      # Caching
      cache-dependencies:
        description: 'Cache NuGet dependencies'
        type: boolean
        required: false
        default: true
      
      cache-key-prefix:
        description: 'Cache key prefix'
        type: string
        required: false
        default: 'nuget'

      cache-nuget-lockfile:
        description: 'Enable setup-dotnet integrated caching (requires packages.lock.json in project). Uses RestorePackagesWithLockFile. Set to true only if your project generates lock files.'
        type: boolean
        required: false
        default: false

      # Platform Configuration
      runs-on:
        description: 'Runner to use. Use string for GitHub-hosted (e.g., ubuntu-latest, windows-latest, macos-latest) or JSON array for self-hosted (e.g., ["self-hosted", "linux"])'
        type: string
        required: false
        default: 'ubuntu-latest'
      
      timeout-minutes:
        description: 'Job timeout in minutes'
        type: number
        required: false
        default: 30
      
      # Matrix Support
      enable-matrix:
        description: 'Enable matrix builds'
        type: boolean
        required: false
        default: false
      
      matrix-os:
        description: 'OS matrix as JSON array'
        type: string
        required: false
        default: '["ubuntu-latest"]'
      
      matrix-dotnet:
        description: '.NET version matrix as JSON array'
        type: string
        required: false
        default: '["8.0.x"]'
      
    secrets:
      DOTNET_NUGET_PUBLISH_API_KEY:
        description: 'NuGet API key for publishing .NET packages to NuGet.org or private feeds'
        required: false
      
      DOCKER_REGISTRY_USERNAME:
        description: 'Username for Docker registry authentication'
        required: false
      
      DOCKER_REGISTRY_PASSWORD:
        description: 'Password for Docker registry authentication'
        required: false
      
      CODECOV_UPLOAD_TOKEN:
        description: 'Codecov token for uploading .NET test coverage reports'
        required: false
      
      SONARCLOUD_ANALYSIS_TOKEN:
        description: 'SonarCloud token for .NET code quality analysis'
        required: false

      DOTNET_SIGNKEY_BASE64:
        description: 'Base64-encoded SNK key for assembly signing (decoded and written to snk-file-path)'
        required: false

    outputs:
      version:
        description: 'Version of the built application/package'
        value: ${{ jobs.build.outputs.version }}
      
      test-results:
        description: 'Path to test results'
        value: ${{ jobs.build.outputs.test-results }}
      
      coverage-report:
        description: 'Path to coverage report'
        value: ${{ jobs.build.outputs.coverage-report }}
      
      package-path:
        description: 'Path to created NuGet package'
        value: ${{ jobs.build.outputs.package-path }}
      
      docker-image:
        description: 'Docker image tag'
        value: ${{ jobs.build.outputs.docker-image }}

jobs:
  build:
    name: Build .NET
    runs-on: ${{ inputs.enable-matrix && matrix.os || (startsWith(inputs.runs-on, '[') && fromJSON(inputs.runs-on) || inputs.runs-on) }}
    timeout-minutes: ${{ inputs.timeout-minutes }}

    defaults:
      run:
        shell: bash

    strategy:
      matrix:
        os: ${{ inputs.enable-matrix && fromJson(inputs.matrix-os) || fromJson(format('["{0}"]', inputs.runs-on)) }}
        dotnet: ${{ inputs.enable-matrix && fromJson(inputs.matrix-dotnet) || fromJson(format('["{0}"]', inputs.dotnet-version)) }}
      fail-fast: false
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      test-results: ${{ steps.test.outputs.results-path }}
      coverage-report: ${{ steps.coverage.outputs.report-path }}
      package-path: ${{ steps.package.outputs.package-path }}
      docker-image: ${{ steps.docker.outputs.image-tag }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          lfs: true
      
      - name: ğŸ”§ Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.enable-matrix && matrix.dotnet || inputs.dotnet-version }}
          global-json-file: ${{ inputs.global-json-file }}
          dotnet-quality: ${{ inputs.dotnet-quality }}
          cache: ${{ inputs.cache-nuget-lockfile }}

      - name: ğŸ”§ Setup Additional .NET Versions
        if: contains(inputs.dotnet-version, ',')
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: |
            ${{ inputs.dotnet-version }}
          cache: ${{ inputs.cache-nuget-lockfile }}
      
      - name: ğŸ“¦ Cache NuGet Packages
        if: inputs.cache-dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.nuget/packages
            ~/.local/share/NuGet/Cache
            ~/Library/Caches/NuGet
            %LocalAppData%\NuGet\Cache
          key: ${{ inputs.cache-key-prefix }}-${{ runner.os }}-${{ hashFiles('**/packages.lock.json', '**/*.csproj', '**/Directory.Build.props') }}
          restore-keys: |
            ${{ inputs.cache-key-prefix }}-${{ runner.os }}-
            ${{ inputs.cache-key-prefix }}-
      
      - name: ğŸ·ï¸ Determine Version
        id: version
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ -n "${{ inputs.package-version }}" ]; then
            VERSION="${{ inputs.package-version }}"
          elif [ -n "$GITHUB_REF_NAME" ] && [[ "$GITHUB_REF_NAME" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="1.0.0-preview.${{ github.run_number }}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: ğŸ” Setup SNK Signing Key
        if: inputs.snk-file-path != '' && env.DOTNET_SIGNKEY_BASE64 != ''
        working-directory: ${{ inputs.working-directory }}
        env:
          DOTNET_SIGNKEY_BASE64: ${{ secrets.DOTNET_SIGNKEY_BASE64 }}
        run: |
          SNK_PATH="${{ inputs.snk-file-path }}"
          SNK_DIR=$(dirname "$SNK_PATH")

          # Create directory if needed
          if [ -n "$SNK_DIR" ] && [ "$SNK_DIR" != "." ]; then
            mkdir -p "$SNK_DIR"
          fi

          # Decode base64 and write SNK file
          echo "$DOTNET_SIGNKEY_BASE64" | base64 -d > "$SNK_PATH"

          # Verify file was created
          if [ -f "$SNK_PATH" ]; then
            FILE_SIZE=$(stat -f%z "$SNK_PATH" 2>/dev/null || stat -c%s "$SNK_PATH" 2>/dev/null || wc -c < "$SNK_PATH")
            echo "âœ… SNK key created: $SNK_PATH ($FILE_SIZE bytes)"
          else
            echo "âŒ Failed to create SNK file"
            exit 1
          fi

      - name: ğŸ“š Restore Dependencies
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Enable Windows targeting on non-Windows platforms to allow building Windows TFMs
          WINDOWS_TARGETING=""
          if [ "$RUNNER_OS" != "Windows" ]; then
            WINDOWS_TARGETING="-p:EnableWindowsTargeting=true"
          fi

          dotnet restore ${{ inputs.project-path }} \
            --verbosity ${{ inputs.verbosity }} \
            $WINDOWS_TARGETING \
            ${{ inputs.runtime && format('--runtime {0}', inputs.runtime) || '' }} \
            ${{ inputs.restore-args }}
      
      - name: ğŸ—ï¸ Build Project
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Enable Windows targeting on non-Windows platforms to allow building Windows TFMs
          WINDOWS_TARGETING=""
          if [ "$RUNNER_OS" != "Windows" ]; then
            WINDOWS_TARGETING="-p:EnableWindowsTargeting=true"
          fi

          dotnet build ${{ inputs.project-path }} \
            --configuration ${{ inputs.configuration }} \
            --no-restore \
            --verbosity ${{ inputs.verbosity }} \
            $WINDOWS_TARGETING \
            ${{ inputs.treat-warnings-as-errors && '--warnaserror' || '' }} \
            ${{ inputs.runtime && format('--runtime {0}', inputs.runtime) || '' }} \
            ${{ inputs.self-contained && '--self-contained' || '' }} \
            -p:Version=${{ steps.version.outputs.version }} \
            ${{ inputs.build-args }}
      
      - name: ğŸ§ª Run Tests
        id: test
        if: inputs.run-tests
        working-directory: ${{ inputs.working-directory }}
        continue-on-error: true
        run: |
          # Use TestResults in working directory
          mkdir -p TestResults

          echo "tests-found=true" >> $GITHUB_OUTPUT

          # Run tests - dotnet test will gracefully handle if no test projects exist
          dotnet test ${{ inputs.project-path }} \
            --configuration ${{ inputs.configuration }} \
            --no-build \
            --verbosity ${{ inputs.verbosity }} \
            --logger "${{ inputs.test-logger }}" \
            --results-directory TestResults \
            ${{ inputs.test-filter && format('--filter "{0}"', inputs.test-filter) || '' }} \
            ${{ inputs.collect-coverage && format('--collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format={0}', inputs.coverage-type) || '' }} \
            ${{ inputs.coverage-exclude && format('-- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.ExcludeByFile={0}', inputs.coverage-exclude) || '' }} \
            ${{ inputs.test-args }}

          # List what was created
          echo "Contents of TestResults:"
          ls -la TestResults/ || echo "Directory empty or not found"

          # Check if any .trx files were created
          TRX_COUNT=$(find TestResults -name "*.trx" 2>/dev/null | wc -l)
          if [ "$TRX_COUNT" -gt 0 ]; then
            echo "âœ… Found $TRX_COUNT test result file(s)"
            # Use workspace-relative path for cross-platform compatibility
            WORKING_DIR="${{ inputs.working-directory }}"
            if [ "$WORKING_DIR" = "." ]; then
              echo "results-path=TestResults" >> $GITHUB_OUTPUT
            else
              echo "results-path=${WORKING_DIR}/TestResults" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ No test results (.trx) files found"
            echo "tests-found=false" >> $GITHUB_OUTPUT
            echo "results-path=" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ“Š Process Coverage
        id: coverage
        if: inputs.collect-coverage && steps.test.outputs.results-path != ''
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          COVERAGE_FILE=$(find TestResults -name "coverage.${{ inputs.coverage-type }}.xml" -type f 2>/dev/null | head -1)

          if [ -n "$COVERAGE_FILE" ]; then
            echo "Coverage report: $COVERAGE_FILE"
            echo "report-path=${{ steps.test.outputs.results-path }}/${COVERAGE_FILE#TestResults/}" >> $GITHUB_OUTPUT

            # Check threshold if specified
            if [ "${{ inputs.coverage-threshold }}" -gt 0 ]; then
              echo "Coverage threshold check: ${{ inputs.coverage-threshold }}%"
            fi
          else
            echo "No coverage file found"
            echo "report-path=" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ“Š Upload Coverage to Codecov
        if: inputs.collect-coverage && steps.coverage.outputs.report-path != ''
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_UPLOAD_TOKEN }}
          file: ${{ steps.coverage.outputs.report-path }}
          fail_ci_if_error: false
          verbose: true
      
      - name: ğŸ” Code Analysis
        if: inputs.run-code-analysis
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Enable Windows targeting on non-Windows platforms
          WINDOWS_TARGETING=""
          if [ "$RUNNER_OS" != "Windows" ]; then
            WINDOWS_TARGETING="-p:EnableWindowsTargeting=true"
          fi

          dotnet build ${{ inputs.project-path }} \
            --configuration ${{ inputs.configuration }} \
            --no-restore \
            $WINDOWS_TARGETING \
            -p:AnalysisLevel=${{ inputs.analysis-level }} \
            -p:EnableNETAnalyzers=true \
            -p:EnforceCodeStyleInBuild=true
      
      - name: ğŸ“¦ Publish Application
        if: inputs.publish
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Enable Windows targeting on non-Windows platforms
          WINDOWS_TARGETING=""
          if [ "$RUNNER_OS" != "Windows" ]; then
            WINDOWS_TARGETING="-p:EnableWindowsTargeting=true"
          fi

          dotnet publish ${{ inputs.project-path }} \
            --configuration ${{ inputs.configuration }} \
            --output ${{ inputs.output-directory }} \
            --no-build \
            $WINDOWS_TARGETING \
            ${{ inputs.runtime && format('--runtime {0}', inputs.runtime) || '' }} \
            ${{ inputs.self-contained && '--self-contained' || '--no-self-contained' }} \
            -p:Version=${{ steps.version.outputs.version }} \
            ${{ inputs.publish-args }}
      
      - name: ğŸ“¦ Create NuGet Package
        id: package
        if: inputs.create-package
        working-directory: ${{ inputs.working-directory }}
        run: |
          PACKAGE_OUTPUT_DIR="${{ runner.temp }}/packages"
          mkdir -p "$PACKAGE_OUTPUT_DIR"

          # Enable Windows targeting on non-Windows platforms
          WINDOWS_TARGETING=""
          if [ "$RUNNER_OS" != "Windows" ]; then
            WINDOWS_TARGETING="-p:EnableWindowsTargeting=true"
          fi

          dotnet pack ${{ inputs.project-path }} \
            --configuration ${{ inputs.configuration }} \
            --output "$PACKAGE_OUTPUT_DIR" \
            --no-build \
            $WINDOWS_TARGETING \
            -p:PackageVersion=${{ steps.version.outputs.version }} \
            ${{ inputs.include-symbols && '-p:IncludeSymbols=true -p:SymbolPackageFormat=snupkg' || '' }} \
            ${{ inputs.include-source && '-p:IncludeSource=true' || '' }}
          
          PACKAGE_FILE=$(find "$PACKAGE_OUTPUT_DIR" -name "*.nupkg" -type f | head -1)
          echo "package-path=$PACKAGE_FILE" >> $GITHUB_OUTPUT
          echo "Package created: $PACKAGE_FILE"
      
      - name: ğŸ“¤ Push to NuGet
        if: inputs.push-to-nuget && steps.package.outputs.package-path != ''
        run: |
          dotnet nuget push "${{ steps.package.outputs.package-path }}" \
            --api-key ${{ secrets.DOTNET_NUGET_PUBLISH_API_KEY }} \
            --source ${{ inputs.nuget-source }} \
            --skip-duplicate
      
      - name: ğŸ³ Build Docker Image
        id: docker
        if: inputs.build-docker
        run: |
          IMAGE_NAME="${{ inputs.docker-image-name }}"
          if [ -z "$IMAGE_NAME" ]; then
            IMAGE_NAME="${{ github.repository }}:${{ steps.version.outputs.version }}"
          fi
          
          docker build \
            -f ${{ inputs.dockerfile-path }} \
            -t "$IMAGE_NAME" \
            --build-arg VERSION=${{ steps.version.outputs.version }} \
            --build-arg CONFIGURATION=${{ inputs.configuration }} \
            ${{ inputs.working-directory }}
          
          echo "image-tag=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Docker image built: $IMAGE_NAME"
      
      - name: ğŸ³ Push Docker Image
        if: inputs.build-docker && inputs.docker-registry != ''
        run: |
          echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login ${{ inputs.docker-registry }} -u "${{ secrets.DOCKER_REGISTRY_USERNAME }}" --password-stdin
          
          FULL_IMAGE_NAME="${{ inputs.docker-registry }}/${{ steps.docker.outputs.image-tag }}"
          docker tag "${{ steps.docker.outputs.image-tag }}" "$FULL_IMAGE_NAME"
          docker push "$FULL_IMAGE_NAME"
          
          # Also push latest tag for main branch
          if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            LATEST_TAG="${{ inputs.docker-registry }}/${{ inputs.docker-image-name }}:latest"
            docker tag "${{ steps.docker.outputs.image-tag }}" "$LATEST_TAG"
            docker push "$LATEST_TAG"
          fi
      
      - name: ğŸ“Š Test Report
        if: always() && inputs.run-tests && steps.test.outputs.results-path != ''
        uses: dorny/test-reporter@v2
        continue-on-error: true
        with:
          name: 'Test Results - ${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}'
          path: '${{ steps.test.outputs.results-path }}/**/*.trx'
          reporter: 'dotnet-trx'
          fail-on-error: false
      
      - name: ğŸ“¤ Upload Build Artifacts
        if: inputs.upload-artifacts && inputs.publish
        uses: actions/upload-artifact@v6
        with:
          name: ${{ inputs.artifact-name }}-${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}-${{ steps.version.outputs.version }}
          path: |
            ${{ inputs.output-directory }}
            ${{ inputs.artifact-path }}
          retention-days: ${{ inputs.artifact-retention-days }}
      
      - name: ğŸ“¤ Upload Package Artifacts
        if: inputs.upload-artifacts && inputs.create-package
        uses: actions/upload-artifact@v6
        with:
          name: nuget-packages-${{ steps.version.outputs.version }}
          path: ${{ steps.package.outputs.package-path }}
          retention-days: ${{ inputs.artifact-retention-days }}
      
      - name: ğŸ“¤ Upload Test Results
        if: always() && inputs.run-tests && inputs.upload-artifacts && steps.test.outputs.results-path != ''
        uses: actions/upload-artifact@v6
        continue-on-error: true
        with:
          name: test-results-${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}
          path: ${{ steps.test.outputs.results-path }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: ignore
      
      - name: ğŸ“¤ Upload Coverage Report
        if: inputs.collect-coverage && inputs.upload-artifacts && steps.coverage.outputs.report-path != ''
        uses: actions/upload-artifact@v6
        with:
          name: coverage-report-${{ inputs.enable-matrix && matrix.os || inputs.runs-on }}
          path: ${{ steps.coverage.outputs.report-path }}
          retention-days: ${{ inputs.artifact-retention-days }}