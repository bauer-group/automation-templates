name: üîÑ Meta Repository Submodule Sync

on:
  workflow_call:
    secrets:
      GITHUB_PAT:
        description: 'GitHub Personal Access Token with repo scope (required for private repos)'
        required: false

    inputs:
      # Configuration
      config-file:
        description: 'Configuration file path (JSON) defining topic groups'
        type: string
        required: false
        default: '.github/config/meta-repository/topics.json'

      organization:
        description: 'GitHub organization name (defaults to repository owner)'
        type: string
        required: false
        default: ''

      include-private:
        description: 'Include private repositories in addition to public ones'
        type: boolean
        required: false
        default: false

      # Repository Settings
      base-branch:
        description: 'Main branch name to use (auto-detects default branch if empty)'
        type: string
        required: false
        default: ''

      # README Configuration
      readme-template:
        description: 'Path to README template file'
        type: string
        required: false
        default: '.github/config/meta-repository/README.template.md'

      generate-readme:
        description: 'Generate README.md from template and configuration'
        type: boolean
        required: false
        default: true

      # Output Formats
      generate-json:
        description: 'Generate JSON files for each topic group'
        type: boolean
        required: false
        default: true

      generate-txt:
        description: 'Generate TXT files for each topic group'
        type: boolean
        required: false
        default: true

      output-directory:
        description: 'Directory for output files (JSON/TXT)'
        type: string
        required: false
        default: '.'

      # Submodule Options
      submodule-depth:
        description: 'Git clone depth for submodules (0 = full history)'
        type: number
        required: false
        default: 1

      # Schedule Options
      auto-commit:
        description: 'Automatically commit and push changes'
        type: boolean
        required: false
        default: true

      commit-message:
        description: 'Commit message template'
        type: string
        required: false
        default: 'üîÑ Auto-sync: Update submodules and metadata'

      skip-ci:
        description: 'Add [skip ci] to commit message to prevent triggering CI workflows'
        type: boolean
        required: false
        default: false

      # Runner Configuration
      runs-on:
        description: 'Runner OS'
        type: string
        required: false
        default: 'ubuntu-latest'

      timeout-minutes:
        description: 'Job timeout in minutes'
        type: number
        required: false
        default: 30

    outputs:
      sync-summary:
        description: 'Summary of sync operation'
        value: ${{ jobs.sync.outputs.summary }}

      repositories-synced:
        description: 'Number of repositories synced'
        value: ${{ jobs.sync.outputs.repos-count }}

jobs:
  sync:
    name: Sync Submodules & Generate Metadata
    runs-on: ${{ inputs.runs-on }}
    timeout-minutes: ${{ inputs.timeout-minutes }}

    outputs:
      summary: ${{ steps.summary.outputs.result }}
      repos-count: ${{ steps.count.outputs.total }}

    env:
      ORGANIZATION: ${{ inputs.organization || github.repository_owner }}
      # Set GH_TOKEN early for all gh commands (including branch detection)
      # Use PAT_READONLY_ORGANISATION if include-private=true, otherwise use github.token
      GH_TOKEN: ${{ inputs.include-private && secrets.GITHUB_PAT || github.token }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          # SECURITY: Always use github.token for write operations (checkout, commit, push)
          # GITHUB_PAT is only used for reading private repos from organization
          token: ${{ github.token }}
          # IMPORTANT: Don't load submodules here! They'll be synced later after credential setup
          # This prevents failures when .gitmodules contains private repos that github.token can't access
          submodules: false
          fetch-depth: 0

      - name: üîß Setup Environment
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq gh
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

      - name: üîç Detect Default Branch
        id: detect-branch
        run: |
          BASE_BRANCH="${{ inputs.base-branch }}"

          # Auto-detect default branch if not provided
          if [ -z "$BASE_BRANCH" ]; then
            echo "üîç Auto-detecting default branch..."

            # Try to get default branch from repository
            DEFAULT_BRANCH=$(gh api repos/${{ github.repository }} --jq '.default_branch' 2>/dev/null || echo "")

            if [ -n "$DEFAULT_BRANCH" ]; then
              BASE_BRANCH="$DEFAULT_BRANCH"
              echo "‚úÖ Detected default branch: $BASE_BRANCH"
            else
              # Fallback detection from git
              BASE_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
              echo "‚úÖ Using branch from git: $BASE_BRANCH"
            fi
          else
            echo "‚úÖ Using provided base branch: $BASE_BRANCH"
          fi

          # Verify branch exists
          if git rev-parse --verify "origin/$BASE_BRANCH" >/dev/null 2>&1; then
            echo "‚úÖ Branch '$BASE_BRANCH' exists"
          else
            echo "‚ö†Ô∏è Branch '$BASE_BRANCH' not found, trying 'main'..."
            if git rev-parse --verify "origin/main" >/dev/null 2>&1; then
              BASE_BRANCH="main"
              echo "‚úÖ Using 'main' branch"
            elif git rev-parse --verify "origin/master" >/dev/null 2>&1; then
              BASE_BRANCH="master"
              echo "‚úÖ Using 'master' branch"
            else
              echo "‚ùå Could not find a valid branch"
              exit 1
            fi
          fi

          echo "branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo ""
          echo "üìã Using branch: $BASE_BRANCH"

      - name: üìã Load Configuration
        id: load-config
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "‚ùå Configuration file not found: $CONFIG_FILE"
            echo "üìù Creating default configuration..."

            # Create default config
            mkdir -p "$(dirname "$CONFIG_FILE")"
            cat > "$CONFIG_FILE" <<'EOF'
          {
            "title": "Meta Repository",
            "description": "This repository bundles projects by topics",
            "groups": [
              {
                "topic": "example-topic",
                "folder": "Projects",
                "name": "Example Projects",
                "description": "Example project collection",
                "remove_prefix": ""
              }
            ]
          }
          EOF
            echo "‚úÖ Created default configuration at: $CONFIG_FILE"
          fi

          echo "üìñ Reading configuration from: $CONFIG_FILE"

          # Validate JSON
          if ! jq empty "$CONFIG_FILE" 2>/dev/null; then
            echo "‚ùå Invalid JSON in configuration file"
            exit 1
          fi

          # Extract and validate configuration
          TITLE=$(jq -r '.title // "Meta Repository"' "$CONFIG_FILE")
          DESCRIPTION=$(jq -r '.description // "Automated repository collection"' "$CONFIG_FILE")
          GROUP_COUNT=$(jq '.groups | length' "$CONFIG_FILE")

          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "group-count=$GROUP_COUNT" >> $GITHUB_OUTPUT

          echo "‚úÖ Configuration loaded:"
          echo "   Title: $TITLE"
          echo "   Description: $DESCRIPTION"
          echo "   Groups: $GROUP_COUNT"

          # Display groups
          echo ""
          echo "üì¶ Configured Topic Groups:"
          jq -r '.groups[] | "   - Topic: \(.topic) ‚Üí Folder: \(.folder) (\(.name))"' "$CONFIG_FILE"

      - name: üîç Fetch Repositories by Topics
        id: fetch-repos
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          ORG="${ORGANIZATION}"
          OUTPUT_DIR="${{ inputs.output-directory }}"

          mkdir -p "$OUTPUT_DIR"

          echo "üîç Fetching repositories from organization: $ORG"
          echo ""

          # Determine repository type filter
          # Handle both boolean and string values
          INCLUDE_PRIVATE="${{ inputs.include-private }}"
          echo "üîê Include private repositories: $INCLUDE_PRIVATE"

          # Check which token is being used (GH_TOKEN is already set in env)
          if [ "$INCLUDE_PRIVATE" = "true" ] || [ "$INCLUDE_PRIVATE" = "True" ] || [ "$INCLUDE_PRIVATE" = "TRUE" ]; then
            REPO_TYPE="all"
            echo "üì• Fetching ALL repositories (public + private) from organization..."

            # Check if GITHUB_PAT was provided
            if [ -n "${{ secrets.GITHUB_PAT }}" ]; then
              echo "üîë Using provided GITHUB_PAT token (supports private repos)"
            else
              echo "‚ö†Ô∏è WARNING: include-private=true but GITHUB_PAT secret not provided!"
              echo "   The default github.token may not have access to all private repositories."
              echo "   üí° To ensure access to private repos, provide a GITHUB_PAT secret with 'repo' scope"
            fi
          else
            REPO_TYPE="public"
            echo "üì• Fetching PUBLIC repositories from organization..."
            echo "üîë Using default github.token"
          fi

          # Fetch all repos ONCE and cache them (GH_TOKEN is already set)
          echo "üì° API Call: gh api \"orgs/$ORG/repos?type=${REPO_TYPE}&per_page=100\" --paginate"
          gh api "orgs/$ORG/repos?type=${REPO_TYPE}&per_page=100" --paginate > "${OUTPUT_DIR}/_all_repos.json"

          # Verify and analyze fetched data
          TOTAL_ORG_REPOS=$(jq '. | length' "${OUTPUT_DIR}/_all_repos.json")
          PUBLIC_COUNT=$(jq '[.[] | select(.private == false)] | length' "${OUTPUT_DIR}/_all_repos.json")
          PRIVATE_COUNT=$(jq '[.[] | select(.private == true)] | length' "${OUTPUT_DIR}/_all_repos.json")

          echo "‚úÖ Fetched ${TOTAL_ORG_REPOS} repositories (type: ${REPO_TYPE})"
          echo "   üìä Breakdown: ${PUBLIC_COUNT} public, ${PRIVATE_COUNT} private"
          echo ""

          TOTAL_REPOS=0

          # Process each topic group using cached data
          # Use process substitution to avoid subshell variable scope issues
          while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')
            NAME=$(echo "$group" | jq -r '.name')
            DESC=$(echo "$group" | jq -r '.description')

            echo "üìÇ Processing group: $NAME (topic: $TOPIC)"

            # Filter cached repos by topic
            jq --arg topic "$TOPIC" \
              '[.[]
                | select(.topics[]? == $topic)
                | {
                    name: .name,
                    default_branch: .default_branch,
                    html_url: .html_url,
                    git_url: .git_url,
                    description: .description,
                    topics: .topics,
                    updated_at: .updated_at
                  }
              ]' "${OUTPUT_DIR}/_all_repos.json" > "${OUTPUT_DIR}/${TOPIC}.json"

            # Sort and format JSON
            jq 'sort_by(.name)' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.json.tmp"
            mv "${OUTPUT_DIR}/${TOPIC}.json.tmp" "${OUTPUT_DIR}/${TOPIC}.json"

            REPO_COUNT=$(jq 'length' "${OUTPUT_DIR}/${TOPIC}.json")
            TOTAL_REPOS=$((TOTAL_REPOS + REPO_COUNT))

            echo "   Found $REPO_COUNT repositories"
            jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" | sed 's/^/      - /'

            # Generate TXT file if requested
            if [ "${{ inputs.generate-txt }}" = "true" ]; then
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.txt"
              echo "   üìù Created ${TOPIC}.txt"
            fi

            echo ""
          done < <(jq -c '.groups[]' "$CONFIG_FILE")

          echo "total-repos=$TOTAL_REPOS" >> $GITHUB_OUTPUT
          echo ""
          echo "‚úÖ Total repositories found: $TOTAL_REPOS"

          # Clean up cache file
          rm -f "${OUTPUT_DIR}/_all_repos.json"

      - name: üîÑ Sync Submodules
        id: sync-submodules
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          OUTPUT_DIR="${{ inputs.output-directory }}"

          echo "üîÑ Syncing submodules..."
          echo ""

          # Configure git to use the correct token for submodule operations
          # IMPORTANT: Submodules need GLOBAL config, not local!
          if [ "${{ inputs.include-private }}" = "true" ] && [ -n "${{ secrets.GITHUB_PAT }}" ]; then
            echo "üîë Configuring git to use GITHUB_PAT for submodule operations..."

            # Unset the existing extraheader first (both local and global)
            git config --local --unset-all http.https://github.com/.extraheader || true
            git config --global --unset-all http.https://github.com/.extraheader || true

            # Set new extraheader with PAT token in GLOBAL config
            # This is needed because git submodule add creates new git repos that inherit global config
            # Format: "AUTHORIZATION: basic BASE64(x-access-token:TOKEN)"
            AUTH_HEADER="AUTHORIZATION: basic $(echo -n "x-access-token:${{ secrets.GITHUB_PAT }}" | base64 -w 0)"
            git config --global http.https://github.com/.extraheader "$AUTH_HEADER"

            echo "         ‚úÖ Git credentials configured globally for private repo access"
          fi

          # Prevent git from prompting for credentials
          export GIT_TERMINAL_PROMPT=0

          # Initialize and update existing submodules from .gitmodules (if any)
          # This is needed because we disabled automatic submodule checkout
          if [ -f .gitmodules ]; then
            echo "üì¶ Initializing existing submodules from .gitmodules..."

            # Initialize submodules without checkout (just setup .git/config)
            git submodule init

            # Now update (clone/fetch) all submodules with proper credentials
            # This will use the GITHUB_PAT credentials we just configured globally
            # --single-branch: Only fetch the tracked branch (saves bandwidth for repos with many branches)
            # --remote: Update to latest commit on remote branch (not the recorded commit)
            if git submodule update --init --recursive --remote --single-branch --depth ${{ inputs.submodule-depth }} 2>&1; then
              SUBMODULE_COUNT=$(git submodule status | wc -l)
              echo "‚úÖ Successfully initialized/updated $SUBMODULE_COUNT existing submodules"

              # Stage all submodule reference updates
              echo "üìå Staging submodule reference updates..."
              git add .gitmodules
              git submodule foreach --recursive 'git add -A || true' 2>/dev/null || true
              # Stage the submodule commits in the parent repo
              git add -u
            else
              echo "‚ö†Ô∏è Some submodules failed to update (might be newly added or have access issues)"
              echo "   This is expected if .gitmodules references repos we don't have access to yet"
            fi
            echo ""
          else
            echo "üì¶ No existing .gitmodules file found - starting fresh"
            echo ""
          fi

          ADDED=0
          UPDATED=0
          REMOVED=0

          # Process each topic group
          # Use process substitution to avoid subshell variable scope issues
          while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')

            # Get remove_prefix from group config (topic-specific)
            PREFIX_REGEX=$(echo "$group" | jq -r '.remove_prefix // ""')

            echo "üìÇ Syncing folder: $FOLDER (topic: $TOPIC)"
            if [ -n "$PREFIX_REGEX" ]; then
              echo "   Prefix pattern: $PREFIX_REGEX"
            fi

            mkdir -p "$FOLDER"

            # Get list of valid repository names (cleaned)
            if [ -n "$PREFIX_REGEX" ]; then
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" | \
                sed -E "s/${PREFIX_REGEX}//g" > "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"
            else
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"
            fi

            # Remove obsolete submodules
            echo "   üßπ Checking for obsolete submodules..."
            if [ -d "$FOLDER" ]; then
              while read -r dir; do
                submodule_name=$(basename "$dir")

                if ! grep -qx "$submodule_name" "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"; then
                  echo "      ‚ùå Removing obsolete: $submodule_name"
                  git submodule deinit -f "$dir" 2>/dev/null || true
                  git rm -f "$dir" 2>/dev/null || true
                  rm -rf ".git/modules/$dir" 2>/dev/null || true
                  rm -rf "$dir"
                  REMOVED=$((REMOVED + 1))
                fi
              done < <(find "$FOLDER" -mindepth 1 -maxdepth 1 -type d)
            fi

            # Add new submodules (existing ones were already updated by git submodule update --remote)
            echo "   ‚ú® Processing submodules..."
            while read -r repo; do
              name=$(echo "$repo" | jq -r '.name')
              branch=$(echo "$repo" | jq -r '.default_branch // "main"')
              url=$(echo "$repo" | jq -r '.html_url')

              # Fallback for empty branch name
              if [ -z "$branch" ] || [ "$branch" = "null" ]; then
                branch="main"
                echo "      ‚ö†Ô∏è No default branch specified for $name, using 'main'"
              fi

              # Clean name if prefix removal is configured
              if [ -n "$PREFIX_REGEX" ]; then
                clean_name=$(echo "$name" | sed -E "s/${PREFIX_REGEX}//g")
              else
                clean_name="$name"
              fi

              path="$FOLDER/$clean_name"

              # Only add if submodule doesn't exist yet
              if [ ! -d "$path" ]; then
                echo "      ‚ûï Adding new submodule: $clean_name (branch: $branch)"
                echo "         üìç URL: $url"
                echo "         üìÅ Path: $path"

                # Try to add submodule and capture actual error
                if git submodule add -b "$branch" "$url" "$path" 2>&1; then
                  echo "         ‚úÖ Successfully added $clean_name"
                  ADDED=$((ADDED + 1))
                  # Stage the new submodule
                  git add "$path" .gitmodules
                else
                  ERROR_CODE=$?
                  echo "         ‚ùå Failed to add $clean_name (exit code: $ERROR_CODE)"
                  echo "         üí° This repo might already be in .gitmodules or the directory exists"

                  # Check if it's in .gitmodules
                  if grep -q "path = $path" .gitmodules 2>/dev/null; then
                    echo "         üìã Found in .gitmodules - treating as existing submodule"
                  fi
                fi
              else
                # Submodule already exists - it was updated by "git submodule update --remote"
                # Just verify it's properly tracked
                echo "      ‚úì Submodule exists: $clean_name"
                UPDATED=$((UPDATED + 1))

                # Stage the submodule reference (commit pointer) if it changed
                git add "$path" 2>/dev/null || true
              fi
            done < <(jq -c '.[]' "${OUTPUT_DIR}/${TOPIC}.json")

            echo ""
          done < <(jq -c '.groups[]' "$CONFIG_FILE")

          # Save statistics
          echo "added=$ADDED" >> $GITHUB_OUTPUT
          echo "updated=$UPDATED" >> $GITHUB_OUTPUT
          echo "removed=$REMOVED" >> $GITHUB_OUTPUT

          echo "‚úÖ Submodule sync complete:"
          echo "   Added: $ADDED"
          echo "   Updated: $UPDATED"
          echo "   Removed: $REMOVED"

          # IMPORTANT: Reset git credentials back to github.token for push operations
          # The GITHUB_PAT is read-only and should NOT be used for pushing to meta repo
          if [ "${{ inputs.include-private }}" = "true" ] && [ -n "${{ secrets.GITHUB_PAT }}" ]; then
            echo "üîÑ Resetting git credentials to github.token for push operations..."

            # Unset PAT credentials from global config
            git config --global --unset-all http.https://github.com/.extraheader || true

            # Set github.token in local config for push to meta repo
            # Local takes priority over global, so this overrides for the main repo
            AUTH_HEADER="AUTHORIZATION: basic $(echo -n "x-access-token:${{ github.token }}" | base64 -w 0)"
            git config --local http.https://github.com/.extraheader "$AUTH_HEADER"

            echo "         ‚úÖ Git credentials reset to github.token (local)"
          fi

      - name: üìù Generate README
        id: generate-readme
        if: inputs.generate-readme
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          TEMPLATE_FILE="${{ inputs.readme-template }}"
          OUTPUT_DIR="${{ inputs.output-directory }}"
          ORG="${ORGANIZATION}"

          # Get variables for template replacement
          TITLE=$(jq -r '.title // "Meta Repository"' "$CONFIG_FILE")
          DESCRIPTION=$(jq -r '.description // "Automated Repository Collection"' "$CONFIG_FILE")
          DATE=$(date -u '+%Y-%m-%d %H:%M UTC')

          # Check if template exists
          if [ -f "$TEMPLATE_FILE" ]; then
            echo "üìñ Using template: $TEMPLATE_FILE"
            cp "$TEMPLATE_FILE" README.md

            # Save variables to temp files to avoid shell interpretation
            echo "$TITLE" > /tmp/var_title.txt
            echo "$DESCRIPTION" > /tmp/var_desc.txt
            echo "$ORG" > /tmp/var_org.txt
            echo "$DATE" > /tmp/var_date.txt

            # Replace template variables using Python for safe handling
            python3 <<'PYSCRIPT'
          import re

          # Read the template
          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          # Read variables from temp files
          with open('/tmp/var_title.txt', 'r', encoding='utf-8') as f:
              title = f.read().strip()
          with open('/tmp/var_desc.txt', 'r', encoding='utf-8') as f:
              desc = f.read().strip()
          with open('/tmp/var_org.txt', 'r', encoding='utf-8') as f:
              org = f.read().strip()
          with open('/tmp/var_date.txt', 'r', encoding='utf-8') as f:
              date = f.read().strip()

          # Replace placeholders
          content = content.replace('{{TITLE}}', title)
          content = content.replace('{{DESCRIPTION}}', desc)
          content = content.replace('{{ORGANIZATION}}', org)
          content = content.replace('{{DATE}}', date)

          # Write back
          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)
          PYSCRIPT

            # Clean up temp files
            rm -f /tmp/var_*.txt
          else
            echo "üìù Creating README from configuration..."
            # Use jq to safely generate README with special characters
            jq -n --arg title "$TITLE" \
                  --arg desc "$DESCRIPTION" \
                  --arg org "$ORG" \
                  --arg date "$DATE" \
                  '"# " + $title + "\n\n" + $desc + "\n\n**Organization:** `" + $org + "`\n**Last Updated:** " + $date + "\n\n---\n\n__GROUPS_PLACEHOLDER__\n\n---\n\n*This repository is automatically maintained. Changes are synchronized periodically.*"' -r > README.md
          fi

          # Generate groups section
          GROUPS_CONTENT=""
          jq -c '.groups[]' "$CONFIG_FILE" | while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')
            NAME=$(echo "$group" | jq -r '.name')
            DESC=$(echo "$group" | jq -r '.description')
            PREFIX_REGEX=$(echo "$group" | jq -r '.remove_prefix // ""')

            # Start group section
            echo "## ${NAME}" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
            echo "${DESC}" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
            echo "| Repository | Description | Link |" >> /tmp/groups.md
            echo "|------------|-------------|------|" >> /tmp/groups.md

            # Add repositories (use topic-specific prefix)
            if [ -n "$PREFIX_REGEX" ]; then
              jq -r --arg prefix "$PREFIX_REGEX" \
                '.[] | "| **\(.name | sub($prefix; ""))** | \(.description // "_No description_") | [View](\(.html_url)) |"' \
                "${OUTPUT_DIR}/${TOPIC}.json" >> /tmp/groups.md
            else
              jq -r '.[] | "| **\(.name)** | \(.description // "_No description_") | [View](\(.html_url)) |"' \
                "${OUTPUT_DIR}/${TOPIC}.json" >> /tmp/groups.md
            fi

            echo "" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
          done

          # Replace groups placeholder (supports both {{GROUPS}} and __GROUPS_PLACEHOLDER__)
          if grep -q "{{GROUPS}}" README.md; then
            # Use awk to replace {{GROUPS}} with file content
            awk '/\{\{GROUPS\}\}/ {system("cat /tmp/groups.md"); next} 1' README.md > README.md.tmp
            mv README.md.tmp README.md
          elif grep -q "__GROUPS_PLACEHOLDER__" README.md; then
            # Use awk to replace __GROUPS_PLACEHOLDER__ with file content
            awk '/__GROUPS_PLACEHOLDER__/ {system("cat /tmp/groups.md"); next} 1' README.md > README.md.tmp
            mv README.md.tmp README.md
          else
            # Append if placeholder not found
            cat /tmp/groups.md >> README.md
          fi

          echo "‚úÖ README.md generated"

      - name: üìä Generate Summary
        id: summary
        run: |
          TOTAL_REPOS="${{ steps.fetch-repos.outputs.total-repos }}"
          ADDED="${{ steps.sync-submodules.outputs.added }}"
          UPDATED="${{ steps.sync-submodules.outputs.updated }}"
          REMOVED="${{ steps.sync-submodules.outputs.removed }}"

          SUMMARY="Synced ${TOTAL_REPOS} repositories: ${ADDED} added, ${UPDATED} updated, ${REMOVED} removed"
          echo "result=${SUMMARY}" >> $GITHUB_OUTPUT

          echo "### üîÑ Meta Repository Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Total Repositories** | ${TOTAL_REPOS} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Added** | ${ADDED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Updated** | ${UPDATED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Removed** | ${REMOVED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Topic Groups** | ${{ steps.load-config.outputs.group-count }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # List groups
          echo "#### üìã Topic Groups" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          jq -r '.groups[] | "- **\(.name)** (`\(.topic)`) - \(.description)"' "${{ inputs.config-file }}" >> $GITHUB_STEP_SUMMARY

      - name: üíæ Commit and Push Changes
        if: inputs.auto-commit
        run: |
          BASE_BRANCH="${{ steps.detect-branch.outputs.branch }}"

          git add .

          if ! git diff --cached --quiet; then
            # Build commit message with optional [skip ci] suffix
            COMMIT_MSG="${{ inputs.commit-message }}"

            if [ "${{ inputs.skip-ci }}" = "true" ]; then
              # Add [skip ci] to prevent triggering CI workflows
              COMMIT_MSG="${COMMIT_MSG} [skip ci]"
              echo "üö´ Adding [skip ci] to commit message to prevent CI triggers"
            fi

            git commit -m "$COMMIT_MSG"
            git push origin "$BASE_BRANCH"
            echo "‚úÖ Changes committed and pushed to $BASE_BRANCH"
          else
            echo "‚ÑπÔ∏è No changes to commit"
          fi

      - name: üìä Set Output Count
        id: count
        run: |
          echo "total=${{ steps.fetch-repos.outputs.total-repos }}" >> $GITHUB_OUTPUT
