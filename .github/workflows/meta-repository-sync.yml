name: ðŸ”„ Meta Repository Submodule Sync

on:
  workflow_call:
    secrets:
      GITHUB_PAT:
        description: 'GitHub Personal Access Token with repo scope (required for private repos)'
        required: false

    inputs:
      # Configuration
      config-file:
        description: 'Configuration file path (JSON) defining topic groups'
        type: string
        required: false
        default: '.github/config/meta-repository/topics.json'

      organization:
        description: 'GitHub organization name (defaults to repository owner)'
        type: string
        required: false
        default: ''

      include-private:
        description: 'Include private repositories in addition to public ones'
        type: boolean
        required: false
        default: false

      # Repository Settings
      base-branch:
        description: 'Main branch name to use (auto-detects default branch if empty)'
        type: string
        required: false
        default: ''

      # README Configuration
      readme-template:
        description: 'Path to README template file'
        type: string
        required: false
        default: '.github/config/meta-repository/README.template.md'

      generate-readme:
        description: 'Generate README.md from template and configuration'
        type: boolean
        required: false
        default: true

      # Output Formats
      generate-json:
        description: 'Generate JSON files for each topic group'
        type: boolean
        required: false
        default: true

      generate-txt:
        description: 'Generate TXT files for each topic group'
        type: boolean
        required: false
        default: true

      output-directory:
        description: 'Directory for output files (JSON/TXT)'
        type: string
        required: false
        default: '.'

      # Submodule Options
      submodule-depth:
        description: 'Git clone depth for submodules (0 = full history)'
        type: number
        required: false
        default: 1

      # Schedule Options
      auto-commit:
        description: 'Automatically commit and push changes'
        type: boolean
        required: false
        default: true

      commit-message:
        description: 'Commit message template'
        type: string
        required: false
        default: 'ðŸ”„ Auto-sync: Update submodules and metadata'

      # Runner Configuration
      runs-on:
        description: 'Runner OS'
        type: string
        required: false
        default: 'ubuntu-latest'

      timeout-minutes:
        description: 'Job timeout in minutes'
        type: number
        required: false
        default: 30

    outputs:
      sync-summary:
        description: 'Summary of sync operation'
        value: ${{ jobs.sync.outputs.summary }}

      repositories-synced:
        description: 'Number of repositories synced'
        value: ${{ jobs.sync.outputs.repos-count }}

jobs:
  sync:
    name: Sync Submodules & Generate Metadata
    runs-on: ${{ inputs.runs-on }}
    timeout-minutes: ${{ inputs.timeout-minutes }}

    outputs:
      summary: ${{ steps.summary.outputs.result }}
      repos-count: ${{ steps.count.outputs.total }}

    env:
      ORGANIZATION: ${{ inputs.organization || github.repository_owner }}
      # Set GH_TOKEN early for all gh commands (including branch detection)
      # Use PAT_READONLY_ORGANISATION if include-private=true, otherwise use github.token
      GH_TOKEN: ${{ inputs.include-private && secrets.GITHUB_PAT || github.token }}

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          # SECURITY: Always use github.token for write operations (checkout, commit, push)
          # GITHUB_PAT is only used for reading private repos from organization
          token: ${{ github.token }}
          submodules: recursive
          fetch-depth: 0

      - name: ðŸ”§ Setup Environment
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq gh
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

      - name: ðŸ” Detect Default Branch
        id: detect-branch
        run: |
          BASE_BRANCH="${{ inputs.base-branch }}"

          # Auto-detect default branch if not provided
          if [ -z "$BASE_BRANCH" ]; then
            echo "ðŸ” Auto-detecting default branch..."

            # Try to get default branch from repository
            DEFAULT_BRANCH=$(gh api repos/${{ github.repository }} --jq '.default_branch' 2>/dev/null || echo "")

            if [ -n "$DEFAULT_BRANCH" ]; then
              BASE_BRANCH="$DEFAULT_BRANCH"
              echo "âœ… Detected default branch: $BASE_BRANCH"
            else
              # Fallback detection from git
              BASE_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
              echo "âœ… Using branch from git: $BASE_BRANCH"
            fi
          else
            echo "âœ… Using provided base branch: $BASE_BRANCH"
          fi

          # Verify branch exists
          if git rev-parse --verify "origin/$BASE_BRANCH" >/dev/null 2>&1; then
            echo "âœ… Branch '$BASE_BRANCH' exists"
          else
            echo "âš ï¸ Branch '$BASE_BRANCH' not found, trying 'main'..."
            if git rev-parse --verify "origin/main" >/dev/null 2>&1; then
              BASE_BRANCH="main"
              echo "âœ… Using 'main' branch"
            elif git rev-parse --verify "origin/master" >/dev/null 2>&1; then
              BASE_BRANCH="master"
              echo "âœ… Using 'master' branch"
            else
              echo "âŒ Could not find a valid branch"
              exit 1
            fi
          fi

          echo "branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸ“‹ Using branch: $BASE_BRANCH"

      - name: ðŸ“‹ Load Configuration
        id: load-config
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Configuration file not found: $CONFIG_FILE"
            echo "ðŸ“ Creating default configuration..."

            # Create default config
            mkdir -p "$(dirname "$CONFIG_FILE")"
            cat > "$CONFIG_FILE" <<'EOF'
          {
            "title": "Meta Repository",
            "description": "This repository bundles projects by topics",
            "groups": [
              {
                "topic": "example-topic",
                "folder": "Projects",
                "name": "Example Projects",
                "description": "Example project collection",
                "remove_prefix": ""
              }
            ]
          }
          EOF
            echo "âœ… Created default configuration at: $CONFIG_FILE"
          fi

          echo "ðŸ“– Reading configuration from: $CONFIG_FILE"

          # Validate JSON
          if ! jq empty "$CONFIG_FILE" 2>/dev/null; then
            echo "âŒ Invalid JSON in configuration file"
            exit 1
          fi

          # Extract and validate configuration
          TITLE=$(jq -r '.title // "Meta Repository"' "$CONFIG_FILE")
          DESCRIPTION=$(jq -r '.description // "Automated repository collection"' "$CONFIG_FILE")
          GROUP_COUNT=$(jq '.groups | length' "$CONFIG_FILE")

          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "group-count=$GROUP_COUNT" >> $GITHUB_OUTPUT

          echo "âœ… Configuration loaded:"
          echo "   Title: $TITLE"
          echo "   Description: $DESCRIPTION"
          echo "   Groups: $GROUP_COUNT"

          # Display groups
          echo ""
          echo "ðŸ“¦ Configured Topic Groups:"
          jq -r '.groups[] | "   - Topic: \(.topic) â†’ Folder: \(.folder) (\(.name))"' "$CONFIG_FILE"

      - name: ðŸ” Fetch Repositories by Topics
        id: fetch-repos
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          ORG="${ORGANIZATION}"
          OUTPUT_DIR="${{ inputs.output-directory }}"

          mkdir -p "$OUTPUT_DIR"

          echo "ðŸ” Fetching repositories from organization: $ORG"
          echo ""

          # Determine repository type filter
          # Handle both boolean and string values
          INCLUDE_PRIVATE="${{ inputs.include-private }}"
          echo "ðŸ” Include private repositories: $INCLUDE_PRIVATE"

          # Check which token is being used (GH_TOKEN is already set in env)
          if [ "$INCLUDE_PRIVATE" = "true" ] || [ "$INCLUDE_PRIVATE" = "True" ] || [ "$INCLUDE_PRIVATE" = "TRUE" ]; then
            REPO_TYPE="all"
            echo "ðŸ“¥ Fetching ALL repositories (public + private) from organization..."

            # Check if GITHUB_PAT was provided
            if [ -n "${{ secrets.GITHUB_PAT }}" ]; then
              echo "ðŸ”‘ Using provided GITHUB_PAT token (supports private repos)"
            else
              echo "âš ï¸ WARNING: include-private=true but GITHUB_PAT secret not provided!"
              echo "   The default github.token may not have access to all private repositories."
              echo "   ðŸ’¡ To ensure access to private repos, provide a GITHUB_PAT secret with 'repo' scope"
            fi
          else
            REPO_TYPE="public"
            echo "ðŸ“¥ Fetching PUBLIC repositories from organization..."
            echo "ðŸ”‘ Using default github.token"
          fi

          # Fetch all repos ONCE and cache them (GH_TOKEN is already set)
          echo "ðŸ“¡ API Call: gh api \"orgs/$ORG/repos?type=${REPO_TYPE}&per_page=100\" --paginate"
          gh api "orgs/$ORG/repos?type=${REPO_TYPE}&per_page=100" --paginate > "${OUTPUT_DIR}/_all_repos.json"

          # Verify and analyze fetched data
          TOTAL_ORG_REPOS=$(jq '. | length' "${OUTPUT_DIR}/_all_repos.json")
          PUBLIC_COUNT=$(jq '[.[] | select(.private == false)] | length' "${OUTPUT_DIR}/_all_repos.json")
          PRIVATE_COUNT=$(jq '[.[] | select(.private == true)] | length' "${OUTPUT_DIR}/_all_repos.json")

          echo "âœ… Fetched ${TOTAL_ORG_REPOS} repositories (type: ${REPO_TYPE})"
          echo "   ðŸ“Š Breakdown: ${PUBLIC_COUNT} public, ${PRIVATE_COUNT} private"
          echo ""

          TOTAL_REPOS=0

          # Process each topic group using cached data
          jq -c '.groups[]' "$CONFIG_FILE" | while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')
            NAME=$(echo "$group" | jq -r '.name')
            DESC=$(echo "$group" | jq -r '.description')

            echo "ðŸ“‚ Processing group: $NAME (topic: $TOPIC)"

            # Filter cached repos by topic
            jq --arg topic "$TOPIC" \
              '[.[]
                | select(.topics[]? == $topic)
                | {
                    name: .name,
                    default_branch: .default_branch,
                    html_url: .html_url,
                    git_url: .git_url,
                    description: .description,
                    topics: .topics,
                    updated_at: .updated_at
                  }
              ]' "${OUTPUT_DIR}/_all_repos.json" > "${OUTPUT_DIR}/${TOPIC}.json"

            # Sort and format JSON
            jq 'sort_by(.name)' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.json.tmp"
            mv "${OUTPUT_DIR}/${TOPIC}.json.tmp" "${OUTPUT_DIR}/${TOPIC}.json"

            REPO_COUNT=$(jq 'length' "${OUTPUT_DIR}/${TOPIC}.json")
            TOTAL_REPOS=$((TOTAL_REPOS + REPO_COUNT))

            echo "   Found $REPO_COUNT repositories"
            jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" | sed 's/^/      - /'

            # Generate TXT file if requested
            if [ "${{ inputs.generate-txt }}" = "true" ]; then
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.txt"
              echo "   ðŸ“ Created ${TOPIC}.txt"
            fi

            echo ""
          done

          echo "total-repos=$TOTAL_REPOS" >> $GITHUB_OUTPUT
          echo ""
          echo "âœ… Total repositories found: $TOTAL_REPOS"

          # Clean up cache file
          rm -f "${OUTPUT_DIR}/_all_repos.json"

      - name: ðŸ”„ Sync Submodules
        id: sync-submodules
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          OUTPUT_DIR="${{ inputs.output-directory }}"

          echo "ðŸ”„ Syncing submodules..."
          echo ""

          # Configure git to use the correct token for submodule operations
          # This is needed because git submodule add uses the git config credentials
          # Use --local to override the checkout step's credentials
          if [ "${{ inputs.include-private }}" = "true" ] && [ -n "${{ secrets.GITHUB_PAT }}" ]; then
            echo "ðŸ”‘ Configuring git to use GITHUB_PAT for submodule operations..."
            # Update the extraheader to use the PAT token (local config overrides checkout)
            git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n x-access-token:${{ secrets.GITHUB_PAT }} | base64)"
          fi

          ADDED=0
          UPDATED=0
          REMOVED=0

          # Process each topic group
          jq -c '.groups[]' "$CONFIG_FILE" | while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')

            # Get remove_prefix from group config (topic-specific)
            PREFIX_REGEX=$(echo "$group" | jq -r '.remove_prefix // ""')

            echo "ðŸ“‚ Syncing folder: $FOLDER (topic: $TOPIC)"
            if [ -n "$PREFIX_REGEX" ]; then
              echo "   Prefix pattern: $PREFIX_REGEX"
            fi

            mkdir -p "$FOLDER"

            # Get list of valid repository names (cleaned)
            if [ -n "$PREFIX_REGEX" ]; then
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" | \
                sed -E "s/${PREFIX_REGEX}//g" > "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"
            else
              jq -r '.[].name' "${OUTPUT_DIR}/${TOPIC}.json" > "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"
            fi

            # Remove obsolete submodules
            echo "   ðŸ§¹ Checking for obsolete submodules..."
            if [ -d "$FOLDER" ]; then
              find "$FOLDER" -mindepth 1 -maxdepth 1 -type d | while read -r dir; do
                submodule_name=$(basename "$dir")

                if ! grep -qx "$submodule_name" "${OUTPUT_DIR}/${TOPIC}.noprefix.txt"; then
                  echo "      âŒ Removing obsolete: $submodule_name"
                  git submodule deinit -f "$dir" 2>/dev/null || true
                  git rm -f "$dir" 2>/dev/null || true
                  rm -rf ".git/modules/$dir" 2>/dev/null || true
                  rm -rf "$dir"
                  REMOVED=$((REMOVED + 1))
                fi
              done
            fi

            # Add or update submodules
            echo "   âœ¨ Adding/updating submodules..."
            jq -c '.[]' "${OUTPUT_DIR}/${TOPIC}.json" | while read -r repo; do
              name=$(echo "$repo" | jq -r '.name')
              branch=$(echo "$repo" | jq -r '.default_branch // "main"')
              url=$(echo "$repo" | jq -r '.html_url')

              # Fallback for empty branch name
              if [ -z "$branch" ] || [ "$branch" = "null" ]; then
                branch="main"
                echo "      âš ï¸ No default branch specified for $name, using 'main'"
              fi

              # Clean name if prefix removal is configured
              if [ -n "$PREFIX_REGEX" ]; then
                clean_name=$(echo "$name" | sed -E "s/${PREFIX_REGEX}//g")
              else
                clean_name="$name"
              fi

              path="$FOLDER/$clean_name"

              if [ ! -d "$path" ]; then
                echo "      âœ… Adding: $clean_name (branch: $branch)"
                echo "         ðŸ“ URL: $url"
                echo "         ðŸ“ Path: $path"

                # Try to add submodule and capture actual error
                if git submodule add -b "$branch" "$url" "$path" 2>&1; then
                  echo "         âœ… Successfully added $clean_name"
                  ADDED=$((ADDED + 1))
                else
                  ERROR_CODE=$?
                  echo "         âŒ Failed to add $clean_name (exit code: $ERROR_CODE)"
                  echo "         ðŸ’¡ This repo might already be in .gitmodules or the directory exists"

                  # Check if it's in .gitmodules
                  if grep -q "path = $path" .gitmodules 2>/dev/null; then
                    echo "         ðŸ“‹ Found in .gitmodules - treating as existing submodule"
                  fi
                fi
              else
                echo "      ðŸ”„ Updating: $clean_name"
                (
                  cd "$path"
                  git fetch origin "$branch" --depth ${{ inputs.submodule-depth }} 2>/dev/null || true
                  git checkout "$branch" 2>/dev/null || git checkout -B "$branch" "origin/$branch" 2>/dev/null || true
                  git pull origin "$branch" 2>/dev/null || true
                )
                UPDATED=$((UPDATED + 1))
              fi

              # Update submodule to latest commit
              if [ -d "$path" ]; then
                latest_commit=$(cd "$path" && git rev-parse HEAD)
                git add "$path"
              fi
            done

            echo ""
          done

          # Save statistics
          echo "added=$ADDED" >> $GITHUB_OUTPUT
          echo "updated=$UPDATED" >> $GITHUB_OUTPUT
          echo "removed=$REMOVED" >> $GITHUB_OUTPUT

          echo "âœ… Submodule sync complete:"
          echo "   Added: $ADDED"
          echo "   Updated: $UPDATED"
          echo "   Removed: $REMOVED"

          # IMPORTANT: Reset git credentials back to github.token for push operations
          # The GITHUB_PAT is read-only and should NOT be used for pushing to meta repo
          if [ "${{ inputs.include-private }}" = "true" ] && [ -n "${{ secrets.GITHUB_PAT }}" ]; then
            echo "ðŸ”„ Resetting git credentials to github.token for push operations..."
            git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n x-access-token:${{ github.token }} | base64)"
          fi

      - name: ðŸ“ Generate README
        id: generate-readme
        if: inputs.generate-readme
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          TEMPLATE_FILE="${{ inputs.readme-template }}"
          OUTPUT_DIR="${{ inputs.output-directory }}"
          ORG="${ORGANIZATION}"

          # Get variables for template replacement
          TITLE=$(jq -r '.title // "Meta Repository"' "$CONFIG_FILE")
          DESCRIPTION=$(jq -r '.description // "Automated Repository Collection"' "$CONFIG_FILE")
          DATE=$(date -u '+%Y-%m-%d %H:%M UTC')

          # Check if template exists
          if [ -f "$TEMPLATE_FILE" ]; then
            echo "ðŸ“– Using template: $TEMPLATE_FILE"
            cp "$TEMPLATE_FILE" README.md

            # Save variables to temp files to avoid shell interpretation
            echo "$TITLE" > /tmp/var_title.txt
            echo "$DESCRIPTION" > /tmp/var_desc.txt
            echo "$ORG" > /tmp/var_org.txt
            echo "$DATE" > /tmp/var_date.txt

            # Replace template variables using Python for safe handling
            python3 <<'PYSCRIPT'
          import re

          # Read the template
          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          # Read variables from temp files
          with open('/tmp/var_title.txt', 'r', encoding='utf-8') as f:
              title = f.read().strip()
          with open('/tmp/var_desc.txt', 'r', encoding='utf-8') as f:
              desc = f.read().strip()
          with open('/tmp/var_org.txt', 'r', encoding='utf-8') as f:
              org = f.read().strip()
          with open('/tmp/var_date.txt', 'r', encoding='utf-8') as f:
              date = f.read().strip()

          # Replace placeholders
          content = content.replace('{{TITLE}}', title)
          content = content.replace('{{DESCRIPTION}}', desc)
          content = content.replace('{{ORGANIZATION}}', org)
          content = content.replace('{{DATE}}', date)

          # Write back
          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)
          PYSCRIPT

            # Clean up temp files
            rm -f /tmp/var_*.txt
          else
            echo "ðŸ“ Creating README from configuration..."
            # Use jq to safely generate README with special characters
            jq -n --arg title "$TITLE" \
                  --arg desc "$DESCRIPTION" \
                  --arg org "$ORG" \
                  --arg date "$DATE" \
                  '"# " + $title + "\n\n" + $desc + "\n\n**Organization:** `" + $org + "`\n**Last Updated:** " + $date + "\n\n---\n\n__GROUPS_PLACEHOLDER__\n\n---\n\n*This repository is automatically maintained. Changes are synchronized periodically.*"' -r > README.md
          fi

          # Generate groups section
          GROUPS_CONTENT=""
          jq -c '.groups[]' "$CONFIG_FILE" | while read -r group; do
            TOPIC=$(echo "$group" | jq -r '.topic')
            FOLDER=$(echo "$group" | jq -r '.folder')
            NAME=$(echo "$group" | jq -r '.name')
            DESC=$(echo "$group" | jq -r '.description')
            PREFIX_REGEX=$(echo "$group" | jq -r '.remove_prefix // ""')

            # Start group section
            echo "## ${NAME}" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
            echo "${DESC}" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
            echo "| Repository | Description | Link |" >> /tmp/groups.md
            echo "|------------|-------------|------|" >> /tmp/groups.md

            # Add repositories (use topic-specific prefix)
            if [ -n "$PREFIX_REGEX" ]; then
              jq -r --arg prefix "$PREFIX_REGEX" \
                '.[] | "| **\(.name | sub($prefix; ""))** | \(.description // "_No description_") | [View](\(.html_url)) |"' \
                "${OUTPUT_DIR}/${TOPIC}.json" >> /tmp/groups.md
            else
              jq -r '.[] | "| **\(.name)** | \(.description // "_No description_") | [View](\(.html_url)) |"' \
                "${OUTPUT_DIR}/${TOPIC}.json" >> /tmp/groups.md
            fi

            echo "" >> /tmp/groups.md
            echo "" >> /tmp/groups.md
          done

          # Replace groups placeholder (supports both {{GROUPS}} and __GROUPS_PLACEHOLDER__)
          if grep -q "{{GROUPS}}" README.md; then
            # Use awk to replace {{GROUPS}} with file content
            awk '/\{\{GROUPS\}\}/ {system("cat /tmp/groups.md"); next} 1' README.md > README.md.tmp
            mv README.md.tmp README.md
          elif grep -q "__GROUPS_PLACEHOLDER__" README.md; then
            # Use awk to replace __GROUPS_PLACEHOLDER__ with file content
            awk '/__GROUPS_PLACEHOLDER__/ {system("cat /tmp/groups.md"); next} 1' README.md > README.md.tmp
            mv README.md.tmp README.md
          else
            # Append if placeholder not found
            cat /tmp/groups.md >> README.md
          fi

          echo "âœ… README.md generated"

      - name: ðŸ“Š Generate Summary
        id: summary
        run: |
          TOTAL_REPOS="${{ steps.fetch-repos.outputs.total-repos }}"
          ADDED="${{ steps.sync-submodules.outputs.added }}"
          UPDATED="${{ steps.sync-submodules.outputs.updated }}"
          REMOVED="${{ steps.sync-submodules.outputs.removed }}"

          SUMMARY="Synced ${TOTAL_REPOS} repositories: ${ADDED} added, ${UPDATED} updated, ${REMOVED} removed"
          echo "result=${SUMMARY}" >> $GITHUB_OUTPUT

          echo "### ðŸ”„ Meta Repository Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Total Repositories** | ${TOTAL_REPOS} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Added** | ${ADDED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Updated** | ${UPDATED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Submodules Removed** | ${REMOVED} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Topic Groups** | ${{ steps.load-config.outputs.group-count }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # List groups
          echo "#### ðŸ“‹ Topic Groups" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          jq -r '.groups[] | "- **\(.name)** (`\(.topic)`) - \(.description)"' "${{ inputs.config-file }}" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ’¾ Commit and Push Changes
        if: inputs.auto-commit
        run: |
          BASE_BRANCH="${{ steps.detect-branch.outputs.branch }}"

          git add .

          if ! git diff --cached --quiet; then
            git commit -m "${{ inputs.commit-message }}"
            git push origin "$BASE_BRANCH"
            echo "âœ… Changes committed and pushed to $BASE_BRANCH"
          else
            echo "â„¹ï¸ No changes to commit"
          fi

      - name: ðŸ“Š Set Output Count
        id: count
        run: |
          echo "total=${{ steps.fetch-repos.outputs.total-repos }}" >> $GITHUB_OUTPUT
