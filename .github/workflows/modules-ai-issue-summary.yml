name: ðŸ“¦ Module | AI Issue Summary

on:
  workflow_call:
    inputs:
      summary-type:
        description: 'Type of summary to generate (brief, detailed, technical, user-friendly)'
        required: false
        type: string
        default: 'brief'
      add-labels:
        description: 'Whether to add labels based on AI analysis'
        required: false
        type: boolean
        default: true
      add-priority:
        description: 'Whether to add priority labels based on AI analysis'
        required: false
        type: boolean
        default: true
      translate:
        description: 'Translate to language (leave empty for no translation)'
        required: false
        type: string
        default: ''
      custom-prompt:
        description: 'Custom prompt template (overrides default)'
        required: false
        type: string
        default: ''
      model:
        description: 'AI model to use (gpt-4.1-mini, gpt-4.1, gpt-5)'
        required: false
        type: string
        default: 'gpt-4.1-mini'
      comment-template:
        description: 'Template for the comment (use {summary} placeholder)'
        required: false
        type: string
        default: |
          ## ðŸ¤– AI Summary

          {summary}

          ---
          *This summary was automatically generated by AI and may not be 100% accurate.*
      runs-on:
        description: 'Runner to use. Use string for GitHub-hosted (e.g., "ubuntu-latest") or JSON array for self-hosted (e.g., ["self-hosted", "linux"])'
        required: false
        type: string
        default: 'ubuntu-latest'
    secrets:
      token:
        description: 'GitHub Token with issues write permission'
        required: false
      ai-api-key:
        description: 'API key for AI service (if using external service)'
        required: false

permissions:
  issues: write
  pull-requests: write
  models: read
  contents: read

jobs:
  summarize:
    name: ðŸ§  Generate AI Summary
    runs-on: ${{ startsWith(inputs.runs-on, '[') && fromJSON(inputs.runs-on) || inputs.runs-on }}
    
    steps:
      - name: ðŸš€ Checkout Repository
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.token || secrets.GITHUB_TOKEN }}
      
      - name: ðŸ“‹ Get Issue/PR Details
        id: details
        env:
          GITHUB_TOKEN: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo "ðŸ” Extracting issue/PR details..."

          # Function to generate a cryptographically secure delimiter that doesn't exist in content
          generate_safe_delimiter() {
            local content="$1"
            local prefix="$2"
            local delimiter
            local uuid
            while true; do
              # Generate UUID using multiple fallback methods for compatibility
              if command -v uuidgen >/dev/null 2>&1; then
                uuid=$(uuidgen)
              elif [ -f /proc/sys/kernel/random/uuid ]; then
                uuid=$(cat /proc/sys/kernel/random/uuid)
              else
                # Fallback: use /dev/urandom to generate UUID-like string
                uuid=$(head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n' | sed 's/\(..\)\(..\)\(..\)\(..\)\(..\)\(..\)\(..\)\(..\)/\1\2\3\4-\5\6-\7\8-/')
                uuid="${uuid}$(head -c 8 /dev/urandom | od -An -tx1 | tr -d ' \n')"
              fi
              delimiter="${prefix}_${uuid}"
              # Check if delimiter exists in content (as a standalone line)
              if ! echo "$content" | grep -qxF "$delimiter"; then
                echo "$delimiter"
                return
              fi
            done
          }

          # Determine if this is an issue or PR
          if [ -n "${{ github.event.issue }}" ]; then
            echo "type=issue" >> $GITHUB_OUTPUT
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT

            # Generate safe delimiters for each field
            DELIM_TITLE=$(generate_safe_delimiter "$ISSUE_TITLE" "GHEOF_TITLE")
            DELIM_BODY=$(generate_safe_delimiter "$ISSUE_BODY" "GHEOF_BODY")
            DELIM_LABELS=$(generate_safe_delimiter '${{ toJson(github.event.issue.labels.*.name) }}' "GHEOF_LABELS")

            # Use environment variables to safely handle special characters
            {
              echo "title<<${DELIM_TITLE}"
              printf '%s\n' "$ISSUE_TITLE"
              echo "${DELIM_TITLE}"
            } >> $GITHUB_OUTPUT

            # Use heredoc for body to handle special characters
            {
              echo "body<<${DELIM_BODY}"
              printf '%s\n' "$ISSUE_BODY"
              echo "${DELIM_BODY}"
            } >> $GITHUB_OUTPUT

            echo "author=${{ github.event.issue.user.login }}" >> $GITHUB_OUTPUT

            # Use heredoc for labels JSON
            {
              echo "labels<<${DELIM_LABELS}"
              echo '${{ toJson(github.event.issue.labels.*.name) }}'
              echo "${DELIM_LABELS}"
            } >> $GITHUB_OUTPUT

          elif [ -n "${{ github.event.pull_request }}" ]; then
            echo "type=pull_request" >> $GITHUB_OUTPUT
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT

            # Generate safe delimiters for each field
            DELIM_TITLE=$(generate_safe_delimiter "$PR_TITLE" "GHEOF_TITLE")
            DELIM_BODY=$(generate_safe_delimiter "$PR_BODY" "GHEOF_BODY")
            DELIM_LABELS=$(generate_safe_delimiter '${{ toJson(github.event.pull_request.labels.*.name) }}' "GHEOF_LABELS")

            # Use environment variables to safely handle special characters
            {
              echo "title<<${DELIM_TITLE}"
              printf '%s\n' "$PR_TITLE"
              echo "${DELIM_TITLE}"
            } >> $GITHUB_OUTPUT

            # Use heredoc for body to handle special characters
            {
              echo "body<<${DELIM_BODY}"
              printf '%s\n' "$PR_BODY"
              echo "${DELIM_BODY}"
            } >> $GITHUB_OUTPUT

            echo "author=${{ github.event.pull_request.user.login }}" >> $GITHUB_OUTPUT

            # Use heredoc for labels JSON
            {
              echo "labels<<${DELIM_LABELS}"
              echo '${{ toJson(github.event.pull_request.labels.*.name) }}'
              echo "${DELIM_LABELS}"
            } >> $GITHUB_OUTPUT
          fi
      
      - name: ðŸŽ¯ Prepare Prompt
        id: prompt
        env:
          DETAILS_BODY: ${{ steps.details.outputs.body }}
          DETAILS_TITLE: ${{ steps.details.outputs.title }}
          DETAILS_TYPE: ${{ steps.details.outputs.type }}
          DETAILS_AUTHOR: ${{ steps.details.outputs.author }}
          SUMMARY_TYPE: ${{ inputs.summary-type }}
          CUSTOM_PROMPT: ${{ inputs.custom-prompt }}
          TRANSLATE_TO: ${{ inputs.translate }}
          ADD_LABELS: ${{ inputs.add-labels }}
          ADD_PRIORITY: ${{ inputs.add-priority }}
        run: |
          echo "ðŸ“ Preparing AI prompt..."

          # Use environment variables directly - no heredocs needed for reading
          ISSUE_BODY="$DETAILS_BODY"
          ISSUE_TITLE="$DETAILS_TITLE"

          # Build prompt using printf to file - completely safe, no heredocs
          # Check if custom prompt is provided
          if [ -n "$CUSTOM_PROMPT" ]; then
            printf '%s\n' "$CUSTOM_PROMPT" > /tmp/prompt.txt
          else
            # Build prompt based on summary type using printf (safe for all characters)
            case "$SUMMARY_TYPE" in
              "detailed")
                {
                  printf '%s\n\n' "Provide a detailed analysis of the following GitHub $DETAILS_TYPE:"
                  printf '%s\n' "Title: $ISSUE_TITLE"
                  printf '%s\n' "Author: $DETAILS_AUTHOR"
                  printf '%s\n\n' "Body: $ISSUE_BODY"
                  printf '%s\n' "Please include:"
                  printf '%s\n' "1. A comprehensive summary of the issue/request"
                  printf '%s\n' "2. Key points and requirements"
                  printf '%s\n' "3. Potential impact and scope"
                  printf '%s\n' "4. Suggested next steps"
                  printf '%s\n' "5. Any missing information needed"
                } > /tmp/prompt.txt
                ;;

              "technical")
                {
                  printf '%s\n\n' "Provide a technical summary of the following GitHub $DETAILS_TYPE:"
                  printf '%s\n' "Title: $ISSUE_TITLE"
                  printf '%s\n\n' "Body: $ISSUE_BODY"
                  printf '%s\n' "Focus on:"
                  printf '%s\n' "- Technical requirements and constraints"
                  printf '%s\n' "- Implementation considerations"
                  printf '%s\n' "- Potential challenges"
                  printf '%s\n' "- Architecture/design implications"
                  printf '%s\n' "- Performance considerations"
                } > /tmp/prompt.txt
                ;;

              "user-friendly")
                {
                  printf '%s\n\n' "Provide a simple, non-technical summary of the following GitHub $DETAILS_TYPE:"
                  printf '%s\n' "Title: $ISSUE_TITLE"
                  printf '%s\n\n' "Body: $ISSUE_BODY"
                  printf '%s\n' "Explain in plain language:"
                  printf '%s\n' "- What the user is asking for"
                  printf '%s\n' "- Why it might be important"
                  printf '%s\n' "- What the expected outcome is"
                  printf '%s\n' "Use simple terms and avoid technical jargon."
                } > /tmp/prompt.txt
                ;;

              *)  # brief (default)
                {
                  printf '%s\n\n' "Summarize the following GitHub $DETAILS_TYPE in 2-3 concise sentences:"
                  printf '%s\n' "Title: $ISSUE_TITLE"
                  printf '%s\n\n' "Body: $ISSUE_BODY"
                  printf '%s\n' "Be clear and to the point."
                } > /tmp/prompt.txt
                ;;
            esac
          fi

          # Add translation request if needed
          if [ -n "$TRANSLATE_TO" ]; then
            printf '\n%s\n' "Please provide the summary in $TRANSLATE_TO language." >> /tmp/prompt.txt
          fi

          # Add labeling request if needed
          if [ "$ADD_LABELS" = "true" ]; then
            printf '\n%s\n' "Additionally, suggest appropriate labels from this list: bug, enhancement, documentation, question, help-wanted, good-first-issue, breaking-change, performance, security, test" >> /tmp/prompt.txt
          fi

          # Add priority request if needed
          if [ "$ADD_PRIORITY" = "true" ]; then
            printf '\n%s\n' "Also, suggest a priority level: low, medium, high, critical" >> /tmp/prompt.txt
          fi

          # Set output
          echo "prompt-file=/tmp/prompt.txt" >> $GITHUB_OUTPUT
      
      - name: ðŸ§  Run AI Inference (GitHub Models)
        id: inference-github
        if: ${{ !inputs.custom-prompt || !contains(inputs.model, 'gpt') }}
        continue-on-error: true
        uses: actions/ai-inference@v1
        with:
          prompt-file: ${{ steps.prompt.outputs.prompt-file }}
          model: ${{ inputs.model }}
      
      - name: ðŸ§  Run AI Inference (OpenAI)
        id: inference-openai
        if: ${{ contains(inputs.model, 'gpt') }}
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.ai-api-key }}
          AI_MODEL: ${{ inputs.model }}
          PROMPT_FILE: ${{ steps.prompt.outputs.prompt-file }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "âš ï¸ OpenAI API key not configured, skipping..."
            exit 1
          fi

          echo "ðŸ¤– Using OpenAI API..."

          # Read prompt and escape it properly for JSON
          PROMPT=$(cat "$PROMPT_FILE" | jq -Rs .)

          # Escape model name for JSON safety
          MODEL_JSON=$(printf '%s' "$AI_MODEL" | jq -Rs .)

          # Make API call to OpenAI with properly escaped content
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": $MODEL_JSON,
              \"messages\": [{\"role\": \"user\", \"content\": $PROMPT}],
              \"temperature\": 0.7,
              \"max_tokens\": 500
            }" | jq -r '.choices[0].message.content')

          if [ "$RESPONSE" = "null" ] || [ -z "$RESPONSE" ]; then
            echo "âš ï¸ Failed to get response from OpenAI"
            exit 1
          fi

          # Write response to file first (safe for any content)
          printf '%s' "$RESPONSE" > /tmp/openai_response.txt

          # Generate safe delimiter using UUID with fallbacks
          generate_uuid() {
            if command -v uuidgen >/dev/null 2>&1; then
              uuidgen
            elif [ -f /proc/sys/kernel/random/uuid ]; then
              cat /proc/sys/kernel/random/uuid
            else
              head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n'
            fi
          }

          # Keep generating until we find a delimiter that doesn't exist in the content
          while true; do
            DELIMITER="GHEOF_OPENAI_$(generate_uuid)"
            if ! grep -qxF "$DELIMITER" /tmp/openai_response.txt; then
              break
            fi
          done

          {
            echo "response<<${DELIMITER}"
            cat /tmp/openai_response.txt
            echo ""  # Ensure newline before delimiter
            echo "${DELIMITER}"
          } >> $GITHUB_OUTPUT

      - name: ðŸ§  Fallback Summary (No AI)
        id: fallback
        if: ${{ steps.inference-github.outcome != 'success' && steps.inference-openai.outcome != 'success' }}
        env:
          ITEM_TITLE: ${{ steps.details.outputs.title }}
          ITEM_TYPE: ${{ steps.details.outputs.type }}
          ITEM_AUTHOR: ${{ steps.details.outputs.author }}
        run: |
          echo "âš ï¸ AI inference failed, generating basic summary..."

          # Write content to file first (completely safe)
          {
            printf '**Type:** %s\n' "$ITEM_TYPE"
            printf '**Title:** %s\n' "$ITEM_TITLE"
            printf '**Author:** @%s\n\n' "$ITEM_AUTHOR"
            printf 'This %s requires review. Please check the full description for details.\n' "$ITEM_TYPE"
          } > /tmp/fallback_response.txt

          # Generate safe delimiter using UUID with fallbacks
          generate_uuid() {
            if command -v uuidgen >/dev/null 2>&1; then
              uuidgen
            elif [ -f /proc/sys/kernel/random/uuid ]; then
              cat /proc/sys/kernel/random/uuid
            else
              head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n'
            fi
          }

          # Keep generating until we find a delimiter that doesn't exist in the content
          while true; do
            DELIMITER="GHEOF_FALLBACK_$(generate_uuid)"
            if ! grep -qxF "$DELIMITER" /tmp/fallback_response.txt; then
              break
            fi
          done

          {
            echo "response<<${DELIMITER}"
            cat /tmp/fallback_response.txt
            echo ""  # Ensure newline before delimiter
            echo "${DELIMITER}"
          } >> $GITHUB_OUTPUT

      - name: ðŸ“ Process AI Response
        id: process
        env:
          RESPONSE_GITHUB: ${{ steps.inference-github.outputs.response }}
          RESPONSE_OPENAI: ${{ steps.inference-openai.outputs.response }}
          RESPONSE_FALLBACK: ${{ steps.fallback.outputs.response }}
          GITHUB_OUTCOME: ${{ steps.inference-github.outcome }}
          OPENAI_OUTCOME: ${{ steps.inference-openai.outcome }}
          ADD_LABELS: ${{ inputs.add-labels }}
          ADD_PRIORITY: ${{ inputs.add-priority }}
        run: |
          echo "ðŸ”„ Processing AI response..."

          # Write response directly to file using printf with env var (no variable assignment!)
          # This avoids any shell interpretation of backticks or special characters
          if [ "$GITHUB_OUTCOME" = "success" ]; then
            printf '%s' "$RESPONSE_GITHUB" > /tmp/ai_response.txt
          elif [ "$OPENAI_OUTCOME" = "success" ]; then
            printf '%s' "$RESPONSE_OPENAI" > /tmp/ai_response.txt
          else
            printf '%s' "$RESPONSE_FALLBACK" > /tmp/ai_response.txt
          fi

          # Extract labels if suggested (read from file, not variable)
          if [ "$ADD_LABELS" = "true" ]; then
            SUGGESTED_LABELS=$(grep -oE "(bug|enhancement|documentation|question|help-wanted|good-first-issue|breaking-change|performance|security|test)" /tmp/ai_response.txt 2>/dev/null | sort -u | tr '\n' ' ' | xargs || true)
            echo "suggested-labels=$SUGGESTED_LABELS" >> $GITHUB_OUTPUT
          fi

          # Extract priority if suggested (read from file, not variable)
          if [ "$ADD_PRIORITY" = "true" ]; then
            SUGGESTED_PRIORITY=$(grep -oiE "priority:?\s*(low|medium|high|critical)|(low|medium|high|critical)\s*priority" /tmp/ai_response.txt 2>/dev/null | grep -oiE "(low|medium|high|critical)" | head -1 || true)
            echo "suggested-priority=$SUGGESTED_PRIORITY" >> $GITHUB_OUTPUT
          fi

          # Clean up the summary (remove label/priority suggestions)
          cp /tmp/ai_response.txt /tmp/clean_summary.txt
          if [ "$ADD_LABELS" = "true" ] || [ "$ADD_PRIORITY" = "true" ]; then
            # Remove lines containing label or priority suggestions (case insensitive, various formats)
            sed -i -E '/^[*]*\s*(Suggested\s+)?[Ll]abels?:?/d; /^[*]*\s*(Suggested\s+)?[Pp]riority(\s+level)?:?/d' /tmp/clean_summary.txt
          fi

          # Save clean summary to output (file-based, no variable expansion)
          # Use a cryptographically secure delimiter that is guaranteed not to exist in the content
          generate_uuid() {
            if command -v uuidgen >/dev/null 2>&1; then
              uuidgen
            elif [ -f /proc/sys/kernel/random/uuid ]; then
              cat /proc/sys/kernel/random/uuid
            else
              head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n'
            fi
          }

          # Keep generating until we find a delimiter that doesn't exist in the content
          while true; do
            DELIMITER="GHEOF_SUMMARY_$(generate_uuid)"
            if ! grep -qxF "$DELIMITER" /tmp/clean_summary.txt; then
              break
            fi
          done

          {
            echo "summary<<${DELIMITER}"
            cat /tmp/clean_summary.txt
            echo ""  # Ensure newline before delimiter
            echo "${DELIMITER}"
          } >> $GITHUB_OUTPUT
      
      - name: ðŸ’¬ Post Summary Comment
        env:
          GITHUB_TOKEN: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          COMMENT_TEMPLATE: ${{ inputs.comment-template }}
          SUMMARY_CONTENT: ${{ steps.process.outputs.summary }}
          SUGGESTED_LABELS: ${{ steps.process.outputs.suggested-labels }}
          SUGGESTED_PRIORITY: ${{ steps.process.outputs.suggested-priority }}
          ISSUE_NUMBER: ${{ steps.details.outputs.number }}
        run: |
          echo "ðŸ’¬ Posting summary comment..."

          # Write template and summary to files using printf (safe for all characters)
          printf '%s' "$COMMENT_TEMPLATE" > /tmp/template.txt
          printf '%s' "$SUMMARY_CONTENT" > /tmp/summary.txt

          # Replace {summary} placeholder using awk (safer than sed for arbitrary content)
          awk -v summary="$(cat /tmp/summary.txt)" '{gsub(/{summary}/, summary); print}' /tmp/template.txt > /tmp/final_comment.txt

          # Add label suggestions if any
          if [ -n "$SUGGESTED_LABELS" ]; then
            printf '\n**Suggested Labels:** %s\n' "$SUGGESTED_LABELS" >> /tmp/final_comment.txt
          fi

          # Add priority suggestion if any
          if [ -n "$SUGGESTED_PRIORITY" ]; then
            printf '**Suggested Priority:** %s\n' "$SUGGESTED_PRIORITY" >> /tmp/final_comment.txt
          fi

          # Post the comment using file input for safety
          gh issue comment "$ISSUE_NUMBER" --body-file /tmp/final_comment.txt
      
      - name: ðŸ·ï¸ Apply Suggested Labels
        if: ${{ inputs.add-labels == true && steps.process.outputs.suggested-labels != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          LABELS: ${{ steps.process.outputs.suggested-labels }}
          ISSUE_NUMBER: ${{ steps.details.outputs.number }}
        run: |
          echo "ðŸ·ï¸ Applying suggested labels..."

          for LABEL in $LABELS; do
            echo "Adding label: $LABEL"
            gh issue edit "$ISSUE_NUMBER" --add-label "$LABEL" || echo "Failed to add label: $LABEL"
          done

      - name: ðŸŽ¯ Apply Priority Label
        if: ${{ inputs.add-priority == true && steps.process.outputs.suggested-priority != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          PRIORITY: ${{ steps.process.outputs.suggested-priority }}
          ISSUE_NUMBER: ${{ steps.details.outputs.number }}
        run: |
          echo "ðŸŽ¯ Applying priority label..."

          if [ -n "$PRIORITY" ]; then
            gh issue edit "$ISSUE_NUMBER" --add-label "priority-$PRIORITY"
            echo "Added priority label: priority-$PRIORITY"
          fi

      - name: ðŸ“Š Summary Report
        if: always()
        env:
          ITEM_TITLE: ${{ steps.details.outputs.title }}
          ITEM_TYPE: ${{ steps.details.outputs.type }}
          ITEM_NUMBER: ${{ steps.details.outputs.number }}
          ITEM_AUTHOR: ${{ steps.details.outputs.author }}
          SUMMARY_TYPE: ${{ inputs.summary-type }}
          MODEL: ${{ inputs.model }}
          GITHUB_OUTCOME: ${{ steps.inference-github.outcome }}
          OPENAI_OUTCOME: ${{ steps.inference-openai.outcome }}
          SUGGESTED_LABELS: ${{ steps.process.outputs.suggested-labels }}
          SUGGESTED_PRIORITY: ${{ steps.process.outputs.suggested-priority }}
        run: |
          # Determine AI service used
          if [ "$GITHUB_OUTCOME" = "success" ]; then
            AI_SERVICE="GitHub Models"
          elif [ "$OPENAI_OUTCOME" = "success" ]; then
            AI_SERVICE="OpenAI"
          else
            AI_SERVICE="Fallback (No AI)"
          fi

          {
            echo "### ðŸ¤– AI Issue Summary Report"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            printf '| **Type** | %s |\n' "$ITEM_TYPE"
            printf '| **Number** | #%s |\n' "$ITEM_NUMBER"
            printf '| **Title** | %s |\n' "$ITEM_TITLE"
            printf '| **Author** | @%s |\n' "$ITEM_AUTHOR"
            printf '| **Summary Type** | %s |\n' "$SUMMARY_TYPE"
            printf '| **Model** | %s |\n' "$MODEL"
            printf '| **AI Service** | %s |\n' "$AI_SERVICE"

            if [ -n "$SUGGESTED_LABELS" ]; then
              printf '| **Suggested Labels** | %s |\n' "$SUGGESTED_LABELS"
            fi

            if [ -n "$SUGGESTED_PRIORITY" ]; then
              printf '| **Suggested Priority** | %s |\n' "$SUGGESTED_PRIORITY"
            fi

            echo ""
            echo "âœ… **Summary posted successfully**"
          } >> $GITHUB_STEP_SUMMARY