# =============================================================================
# Docker Base Image Monitor - Reusable Workflow
# =============================================================================
# Monitors Docker base images for digest changes and triggers rebuilds.
# Solves the problem that Dependabot cannot track floating tags (stable/latest).
#
# Features:
# - Monitors multiple images via JSON config or inline definition
# - Auto-creates GitHub variables for digest storage
# - Creates semantic-release compatible commits for automatic versioning
# - Supports dry-run mode for testing
#
# Usage (inline):
#   uses: bauer-group/automation-templates/.github/workflows/modules-docker-base-image-monitor.yml@main
#   with:
#     images: '[{"name": "n8n", "image": "n8nio/n8n", "tag": "stable", "variable": "N8N_STABLE_DIGEST"}]'
#   secrets: inherit
#
# Usage (config file):
#   uses: bauer-group/automation-templates/.github/workflows/modules-docker-base-image-monitor.yml@main
#   with:
#     config-file: '.github/config/docker-base-image-monitor/base-images.json'
#   secrets: inherit
#
# Required Permissions:
#   - PAT with 'repo' scope (Classic) OR
#   - Fine-grained PAT with Variables (Read/Write) + Contents (Read/Write)
# =============================================================================

name: "ğŸ” Module | Docker Base Image Monitor"

on:
  workflow_call:
    inputs:
      images:
        description: "JSON array of images to monitor (alternative to config-file)"
        required: false
        type: string
        default: ""
      config-file:
        description: "Path to JSON config file (alternative to images)"
        required: false
        type: string
        default: ""
      target-workflow:
        description: "Workflow file to trigger on update (optional, uses commit trigger if empty)"
        required: false
        type: string
        default: ""
      target-workflow-ref:
        description: "Branch for workflow_dispatch"
        required: false
        type: string
        default: "main"
      commit-prefix:
        description: "Commit message prefix for semantic release"
        required: false
        type: string
        default: "chore(deps)"
      commit-and-release:
        description: "Create commit to trigger semantic release"
        required: false
        type: boolean
        default: true
      dry-run:
        description: "Only check, do not trigger or update variables"
        required: false
        type: boolean
        default: false
      runs-on:
        description: 'Runner to use. Use string for GitHub-hosted (e.g., "ubuntu-latest") or JSON array for self-hosted (e.g., ["self-hosted", "linux"])'
        required: false
        type: string
        default: "ubuntu-latest"

    secrets:
      PAT_READWRITE_ORGANISATION:
        description: "GitHub PAT with variable write and contents write permissions"
        required: true

    outputs:
      updates-found:
        description: "True if at least one update was found"
        value: ${{ jobs.monitor.outputs.updates-found }}
      updated-images:
        description: "JSON array of updated image names"
        value: ${{ jobs.monitor.outputs.updated-images }}
      triggered:
        description: "True if target workflow was triggered or commit was pushed"
        value: ${{ jobs.monitor.outputs.triggered }}
      commit-sha:
        description: "SHA of the created commit"
        value: ${{ jobs.monitor.outputs.commit-sha }}
      new-digests:
        description: "JSON object with new digests per image"
        value: ${{ jobs.monitor.outputs.new-digests }}

jobs:
  monitor:
    name: "ğŸ” Check Base Images"
    runs-on: ${{ startsWith(inputs.runs-on, '[') && fromJSON(inputs.runs-on) || inputs.runs-on }}
    outputs:
      updates-found: ${{ steps.check.outputs.updates-found }}
      updated-images: ${{ steps.check.outputs.updated-images }}
      triggered: ${{ steps.release.outputs.triggered || steps.dispatch.outputs.triggered || 'false' }}
      commit-sha: ${{ steps.release.outputs.commit-sha }}
      new-digests: ${{ steps.check.outputs.new-digests }}

    steps:
      - name: "ğŸ” Validate PAT_READWRITE_ORGANISATION secret"
        shell: bash
        env:
          PAT_TOKEN: ${{ secrets.PAT_READWRITE_ORGANISATION }}
        run: |
          if [ -z "$PAT_TOKEN" ]; then
            echo "::error::âŒ Secret 'PAT_READWRITE_ORGANISATION' is not defined!"
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  MISSING SECRET: PAT_READWRITE_ORGANISATION"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "  This workflow requires a Personal Access Token (PAT) with"
            echo "  read/write permissions for Variables and Contents."
            echo ""
            echo "  Setup instructions:"
            echo "  1. Create a PAT at: https://github.com/settings/tokens"
            echo "     - Classic: Select 'repo' scope"
            echo "     - Fine-grained: Select 'Variables' + 'Contents' (Read/Write)"
            echo ""
            echo "  2. Add the secret to your repository:"
            echo "     Repository â†’ Settings â†’ Secrets and variables â†’ Actions"
            echo "     â†’ New repository secret"
            echo "     Name: PAT_READWRITE_ORGANISATION"
            echo ""
            echo "  3. Call this workflow with 'secrets: inherit'"
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            exit 1
          fi
          echo "âœ… PAT_READWRITE_ORGANISATION secret is configured"

      - name: "ğŸ“¥ Checkout repository"
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.PAT_READWRITE_ORGANISATION }}
          fetch-depth: 0

      - name: "ğŸ” Check for image updates"
        id: check
        env:
          GH_TOKEN: ${{ secrets.PAT_READWRITE_ORGANISATION }}
          CONFIG_FILE: ${{ inputs.config-file }}
          INLINE_IMAGES: ${{ inputs.images }}
          COMMIT_PREFIX_INPUT: ${{ inputs.commit-prefix }}
          DRY_RUN: ${{ inputs.dry-run }}
        shell: bash
        run: |
          set -euo pipefail

          # Load configuration directly in this step to avoid JSON escaping issues
          echo "::group::ğŸ“„ Loading Configuration"
          if [ -n "$CONFIG_FILE" ]; then
            echo "ğŸ“‚ Loading config from file: $CONFIG_FILE"

            if [ ! -f "$CONFIG_FILE" ]; then
              echo "::error::Config file not found: $CONFIG_FILE"
              exit 1
            fi

            IMAGES=$(jq -c '.images' "$CONFIG_FILE")
            COMMIT_PREFIX=$(jq -r '.settings."commit-prefix" // "'"$COMMIT_PREFIX_INPUT"'"' "$CONFIG_FILE")
            echo "âœ… Loaded $(printf '%s' "$IMAGES" | jq 'length') images from config file"

          elif [ -n "$INLINE_IMAGES" ]; then
            echo "ğŸ“‹ Using inline images configuration"

            if ! printf '%s' "$INLINE_IMAGES" | jq -e '.' > /dev/null 2>&1; then
              echo "::error::Invalid JSON in 'images' input"
              exit 1
            fi

            IMAGES="$INLINE_IMAGES"
            COMMIT_PREFIX="$COMMIT_PREFIX_INPUT"
            echo "âœ… Loaded $(printf '%s' "$IMAGES" | jq 'length') images from inline config"
          else
            echo "::error::Either 'images' or 'config-file' must be provided"
            exit 1
          fi

          # Save commit-prefix for later steps
          echo "commit-prefix=$COMMIT_PREFIX" >> $GITHUB_OUTPUT
          echo "::endgroup::"

          echo "::group::ğŸ“‹ Image Configuration"
          printf '%s' "$IMAGES" | jq -r '.[] | "  - \(.name): \(.image):\(.tag)"'
          echo "::endgroup::"

          UPDATES_FOUND="false"
          UPDATED_IMAGES="[]"
          NEW_DIGESTS="{}"
          UPDATE_DETAILS=""

          # Process each image (using process substitution to preserve variables)
          while IFS= read -r img; do
            NAME=$(printf '%s' "$img" | jq -r '.name')
            IMAGE=$(printf '%s' "$img" | jq -r '.image')
            TAG=$(printf '%s' "$img" | jq -r '.tag')
            VARIABLE=$(printf '%s' "$img" | jq -r '.variable')

            echo "::group::ğŸ³ Checking $NAME ($IMAGE:$TAG)"

            # Get current digest from registry
            echo "ğŸ“¡ Fetching current digest from Docker Hub..."

            # Try to get digest, handling multi-arch manifests
            CURRENT_DIGEST=""
            MANIFEST_OUTPUT=$(docker manifest inspect "$IMAGE:$TAG" 2>&1) || {
              echo "::warning::Could not fetch manifest for $IMAGE:$TAG"
              echo "::endgroup::"
              continue
            }

            # Try to extract digest (handles both single and multi-arch)
            CURRENT_DIGEST=$(echo "$MANIFEST_OUTPUT" | jq -r '
              if .config.digest then
                .config.digest
              elif .manifests then
                .manifests | sort_by(.platform.architecture) | .[0].digest
              else
                empty
              end
            ' 2>/dev/null || echo "")

            if [ -z "$CURRENT_DIGEST" ]; then
              echo "::warning::Could not extract digest for $IMAGE:$TAG"
              echo "::endgroup::"
              continue
            fi

            echo "ğŸ“¦ Current digest: ${CURRENT_DIGEST:0:20}..."

            # Get stored digest from variable (auto-create if missing)
            echo "ğŸ” Fetching stored digest from variable $VARIABLE..."
            STORED_DIGEST=$(gh variable get "$VARIABLE" 2>/dev/null || echo "")

            if [ -z "$STORED_DIGEST" ]; then
              echo "â„¹ï¸  Variable $VARIABLE does not exist (will be created)"
            else
              echo "ğŸ“¦ Stored digest: ${STORED_DIGEST:0:20}..."
            fi

            # Compare digests
            if [ "$CURRENT_DIGEST" != "$STORED_DIGEST" ]; then
              echo ""
              echo "âœ… Update detected for $NAME!"
              echo "   Old: ${STORED_DIGEST:-<none>}"
              echo "   New: $CURRENT_DIGEST"

              UPDATES_FOUND="true"
              UPDATED_IMAGES=$(echo "$UPDATED_IMAGES" | jq -c --arg name "$NAME" '. + [$name]')
              NEW_DIGESTS=$(echo "$NEW_DIGESTS" | jq -c --arg name "$NAME" --arg digest "$CURRENT_DIGEST" '. + {($name): $digest}')

              # Build update details for commit message
              UPDATE_DETAILS="${UPDATE_DETAILS}
          - $NAME ($IMAGE:$TAG)
            Old: ${STORED_DIGEST:-<none>}
            New: $CURRENT_DIGEST"

              if [ "$DRY_RUN" != "true" ]; then
                # Update or create variable
                echo "ğŸ’¾ Setting variable $VARIABLE..."
                gh variable set "$VARIABLE" --body "$CURRENT_DIGEST"
                echo "âœ… Variable updated"
              else
                echo "ğŸ” DRY RUN: Would set variable $VARIABLE"
              fi
            else
              echo ""
              echo "â„¹ï¸  No update for $NAME (digest unchanged)"
            fi

            echo "::endgroup::"
          done < <(printf '%s' "$IMAGES" | jq -c '.[]')

          # Write outputs
          echo "updates-found=$UPDATES_FOUND" >> $GITHUB_OUTPUT
          echo "updated-images=$UPDATED_IMAGES" >> $GITHUB_OUTPUT
          echo "new-digests=$NEW_DIGESTS" >> $GITHUB_OUTPUT

          # Store update details for commit message (using delimiter for multiline)
          {
            echo "UPDATE_DETAILS<<DETAILS_EOF"
            echo "$UPDATE_DETAILS"
            echo "DETAILS_EOF"
          } >> $GITHUB_ENV

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š Summary"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Updates found: $UPDATES_FOUND"
          if [ "$UPDATES_FOUND" = "true" ]; then
            echo "Updated images: $(echo "$UPDATED_IMAGES" | jq -r 'join(", ")')"
          fi

      - name: "ğŸ“ Create release commit"
        id: release
        if: steps.check.outputs.updates-found == 'true' && inputs.commit-and-release == true && inputs.dry-run != true
        env:
          GH_TOKEN: ${{ secrets.PAT_READWRITE_ORGANISATION }}
          COMMIT_PREFIX: ${{ steps.check.outputs.commit-prefix }}
          UPDATED_IMAGES_JSON: ${{ steps.check.outputs.updated-images }}
        shell: bash
        run: |
          set -euo pipefail

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Get list of updated images for commit message
          UPDATED=$(printf '%s' "$UPDATED_IMAGES_JSON" | jq -r 'join(", ")')

          # Create commit message using heredoc for proper formatting
          COMMIT_MSG=$(cat <<COMMIT_EOF
          ${COMMIT_PREFIX}: update base image ${UPDATED}

          Base image digest changed:
          ${UPDATE_DETAILS}

          Triggered by: Docker Base Image Monitor
          COMMIT_EOF
          )

          # Create an empty commit (the actual change is in GitHub variables)
          git commit --allow-empty -m "$COMMIT_MSG"

          # Push
          git push origin HEAD

          # Get commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "triggered=true" >> $GITHUB_OUTPUT

          echo ""
          echo "âœ… Created commit: $COMMIT_SHA"
          echo "ğŸš€ Semantic release will be triggered by push event"

      - name: "ğŸš€ Trigger target workflow"
        id: dispatch
        if: steps.check.outputs.updates-found == 'true' && inputs.target-workflow != '' && inputs.commit-and-release != true && inputs.dry-run != true
        env:
          GH_TOKEN: ${{ secrets.PAT_READWRITE_ORGANISATION }}
          TARGET_WORKFLOW: ${{ inputs.target-workflow }}
          TARGET_REF: ${{ inputs.target-workflow-ref }}
        shell: bash
        run: |
          echo "ğŸš€ Triggering workflow: $TARGET_WORKFLOW"
          gh workflow run "$TARGET_WORKFLOW" --ref "$TARGET_REF"
          echo "triggered=true" >> $GITHUB_OUTPUT
          echo "âœ… Workflow triggered successfully"

      - name: "ğŸ“‹ Summary"
        if: always()
        env:
          DRY_RUN: ${{ inputs.dry-run }}
          UPDATES_FOUND: ${{ steps.check.outputs.updates-found }}
          UPDATED_IMAGES_JSON: ${{ steps.check.outputs.updated-images }}
          NEW_DIGESTS_JSON: ${{ steps.check.outputs.new-digests }}
          RELEASE_TRIGGERED: ${{ steps.release.outputs.triggered }}
          RELEASE_SHA: ${{ steps.release.outputs.commit-sha }}
          RELEASE_PREFIX: ${{ steps.check.outputs.commit-prefix }}
          DISPATCH_TRIGGERED: ${{ steps.dispatch.outputs.triggered }}
          TARGET_WORKFLOW: ${{ inputs.target-workflow }}
        shell: bash
        run: |
          {
            echo "## ğŸ” Docker Base Image Monitor Results"
            echo ""

            if [ "$DRY_RUN" = "true" ]; then
              echo "> âš ï¸ **Dry run mode** - No changes were made"
              echo ""
            fi

            if [ "$UPDATES_FOUND" = "true" ]; then
              echo "### âœ… Updates found!"
              echo ""
              echo "**Updated images:**"
              printf '%s' "$UPDATED_IMAGES_JSON" | jq -r '.[] | "- `" + . + "`"'
              echo ""
              echo "**New digests:**"
              echo '```json'
              printf '%s' "$NEW_DIGESTS_JSON" | jq '.'
              echo '```'

              if [ "$RELEASE_TRIGGERED" = "true" ]; then
                echo ""
                echo "### ğŸš€ Release triggered"
                echo ""
                echo "| Property | Value |"
                echo "|----------|-------|"
                echo "| **Commit** | \`$RELEASE_SHA\` |"
                echo "| **Prefix** | \`$RELEASE_PREFIX\` |"
                echo ""
                echo "Semantic Release will create a new version based on the commit."
              elif [ "$DISPATCH_TRIGGERED" = "true" ]; then
                echo ""
                echo "### ğŸš€ Workflow triggered"
                echo ""
                echo "Target workflow \`$TARGET_WORKFLOW\` was dispatched."
              fi
            else
              echo "### â„¹ï¸ No updates found"
              echo ""
              echo "All base images are up to date."
            fi
          } >> $GITHUB_STEP_SUMMARY
