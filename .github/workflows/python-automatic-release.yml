name: ðŸ Python Automatic Release

# Reusable Python CI/CD pipeline for external repositories
# Based on automatic-release.yml pattern - simple, smart, and flexible

on:
  workflow_call:
    inputs:
      security-engine:
        description: "Security scan engine"
        type: string
        default: "both"
      force-release:
        description: "Force create release"
        type: boolean
        default: false
      skip-pypi:
        description: "Skip PyPI publishing"
        type: boolean
        default: false
      python-version:
        description: "Python version to use"
        type: string
        default: "3.12"
      package-source-path:
        description: "Path to package source (e.g., src/package_name)"
        type: string
        default: "src"
      version-file:
        description: "Python file containing __version__ (e.g., src/package/__init__.py)"
        type: string
        default: ""
    secrets:
      PYPI_API_TOKEN:
        description: "PyPI API token for publishing"
        required: true
      GITHUB_TOKEN:
        description: "GitHub token for releases and packages"
        required: true
      GITGUARDIAN_API_KEY:
        description: "GitGuardian API key for security scanning"
        required: false
      GITLEAKS_LICENSE:
        description: "Gitleaks Pro license key"
        required: false

jobs:
  # PR validation for pull requests
  pr-validation:
    name: PR Quality Gate
    if: github.event_name == 'pull_request'
    uses: bauer-group/automation-templates/.github/workflows/modules-pr-validation.yml@main
    with:
      enable-security-scan: true
      enable-license-check: true
      enable-commit-lint: true
      security-scan-engine: "gitleaks"
      fail-on-security-issues: true
      fail-on-license-issues: false
    secrets: inherit

  # Python-specific security scan
  python-security-scan:
    name: ðŸ›¡ï¸ Python Security Analysis
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version || '3.12' }}

      - name: ðŸ›¡ï¸ Gitleaks Secret Scan
        if: contains(inputs.security-engine || 'both', 'gitleaks') || contains(inputs.security-engine || 'both', 'both')
        uses: bauer-group/automation-templates/.github/actions/gitleaks-scan@main
        with:
          fail-on-findings: true
          license-key: ${{ secrets.GITLEAKS_LICENSE }}
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: ðŸ›¡ï¸ GitGuardian Security Scan
        if: (contains(inputs.security-engine || 'both', 'gitguardian') || contains(inputs.security-engine || 'both', 'both')) && secrets.GITGUARDIAN_API_KEY
        uses: bauer-group/automation-templates/.github/actions/gitguardian-scan@main
        with:
          api-key: ${{ secrets.GITGUARDIAN_API_KEY }}
          fail-on-findings: false
        continue-on-error: true

      - name: ðŸ” Python Security Tools
        run: |
          # Install Python security tools
          pip install bandit safety

          # Run security checks
          echo "ðŸ” Running bandit security scan..."
          bandit -r . -f json -o bandit-report.json || true

          echo "ðŸ” Running safety dependency check..."
          safety check --json --output safety-report.json || true

      - name: ðŸ“¤ Upload Security Reports
        uses: actions/upload-artifact@v4
        with:
          name: python-security-reports-${{ github.run_number }}
          path: |
            bandit-report.json
            safety-report.json

  # Python build and test (initial validation)
  python-build-test:
    name: ðŸ§ª Python Build & Test
    runs-on: ubuntu-latest

    outputs:
      package-name: ${{ steps.package-info.outputs.name }}
      tests-passed: ${{ steps.test.outcome }}

    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version || '3.12' }}

      - name: ðŸ“¦ Extract Package Info
        id: package-info
        run: |
          if [[ -f "pyproject.toml" ]]; then
            pip install toml
            PACKAGE_NAME=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['name'])" 2>/dev/null || echo "unknown")
          elif [[ -f "setup.py" ]]; then
            PACKAGE_NAME=$(python setup.py --name 2>/dev/null || echo "unknown")
          else
            PACKAGE_NAME="unknown"
          fi

          echo "name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "Package name: $PACKAGE_NAME"

      - name: ðŸ“š Install Dependencies
        run: |
          python -m pip install --upgrade pip

          # Install based on available files
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          fi

          if [[ -f "requirements-dev.txt" ]]; then
            pip install -r requirements-dev.txt
          fi

          if [[ -f "dev-requirements.txt" ]]; then
            pip install -r dev-requirements.txt
          fi

          # Install package in development mode
          if [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
            pip install -e .
          fi

          # Install testing tools
          pip install pytest pytest-cov build twine pytest-html pytest-json-report

      - name: ðŸ§ª Run Tests
        id: test
        run: |
          echo "ðŸ§ª Running comprehensive test suite..."

          # Discover package source path automatically
          PACKAGE_PATH=""
          if [[ -d "${{ inputs.package-source-path }}" ]]; then
            PACKAGE_PATH="${{ inputs.package-source-path }}"
          elif [[ -d "src" ]]; then
            PACKAGE_PATH="src"
          elif [[ -d "lib" ]]; then
            PACKAGE_PATH="lib"
          else
            PACKAGE_PATH="."
          fi

          echo "ðŸ“¦ Using package path: $PACKAGE_PATH"

          # Run pytest with comprehensive options
          if [[ -d "tests" ]]; then
            echo "ðŸ§ª Running pytest on tests/ directory..."
            pytest tests/ \
              --cov="$PACKAGE_PATH" \
              --cov-report=xml \
              --cov-report=html \
              --cov-report=term \
              --html=test-report.html \
              --self-contained-html \
              --json-report --json-report-file=test-report.json \
              --junit-xml=junit-report.xml \
              --verbose || true
          elif [[ -d "test" ]]; then
            echo "ðŸ§ª Running pytest on test/ directory..."
            pytest test/ \
              --cov="$PACKAGE_PATH" \
              --cov-report=xml \
              --cov-report=html \
              --cov-report=term \
              --html=test-report.html \
              --self-contained-html \
              --json-report --json-report-file=test-report.json \
              --junit-xml=junit-report.xml \
              --verbose || true
          else
            echo "â„¹ï¸ No test directory found - running basic package import test"
            python -c "
            import sys
            import os
            sys.path.insert(0, '$PACKAGE_PATH')
            try:
                # Try to import the main package
                import importlib.util
                for root, dirs, files in os.walk('$PACKAGE_PATH'):
                    for file in files:
                        if file == '__init__.py':
                            module_path = os.path.join(root, file)
                            spec = importlib.util.spec_from_file_location('test_module', module_path)
                            if spec and spec.loader:
                                module = importlib.util.module_from_spec(spec)
                                spec.loader.exec_module(module)
                                print(f'âœ… Successfully imported {module_path}')
                print('âœ… Basic import test passed')
            except Exception as e:
                print(f'âŒ Import test failed: {e}')
                sys.exit(1)
            "
          fi

      - name: ðŸ” Run Code Quality Checks
        id: quality
        run: |
          echo "ðŸ” Running code quality checks..."

          # Auto-discover package path
          PACKAGE_PATH=""
          if [[ -d "${{ inputs.package-source-path }}" ]]; then
            PACKAGE_PATH="${{ inputs.package-source-path }}"
          elif [[ -d "src" ]]; then
            PACKAGE_PATH="src"
          elif [[ -d "lib" ]]; then
            PACKAGE_PATH="lib"
          else
            PACKAGE_PATH="."
          fi

          # Install quality tools
          pip install flake8 mypy black isort || true

          # Flake8 linting
          echo "ðŸ“ Running flake8 linting..."
          flake8 "$PACKAGE_PATH" --count --statistics --format=json --output-file=flake8-report.json || true
          flake8 "$PACKAGE_PATH" --count --statistics || true

          # Black formatting check
          echo "ðŸŽ¨ Checking code formatting with black..."
          black --check --diff "$PACKAGE_PATH" || echo "âš ï¸ Code formatting issues found"

          # Import sorting check
          echo "ðŸ“¤ Checking import sorting with isort..."
          isort --check-only --diff "$PACKAGE_PATH" || echo "âš ï¸ Import sorting issues found"

          # MyPy type checking (auto-discover mypy config or use defaults)
          echo "ðŸ”¤ Running mypy type checking..."
          if [[ -f "mypy.ini" ]] || [[ -f ".mypy.ini" ]] || [[ -f "pyproject.toml" ]]; then
            mypy "$PACKAGE_PATH" || echo "âš ï¸ Type checking issues found"
          else
            mypy "$PACKAGE_PATH" --ignore-missing-imports --no-strict-optional || echo "âš ï¸ Type checking issues found (using relaxed settings)"
          fi

      - name: ðŸ§ª Run Additional Test Scripts
        id: additional-scripts
        run: |
          # Run any additional test scripts found in scripts directory
          if [[ -d "scripts" ]]; then
            echo "ðŸ§ª Looking for test scripts in scripts/..."
            find scripts -name "test*.py" -type f | while read script; do
              echo "Running additional Python script: $script"
              python "$script" || echo "âš ï¸ Script $script had issues"
            done
            
            find scripts -name "test*" -type f -executable | while read script; do
              if [[ "$script" != *.py ]]; then
                echo "Running additional executable script: $script"
                "$script" || echo "âš ï¸ Script $script had issues"
              fi
            done
          else
            echo "â„¹ï¸ No scripts directory found"
          fi

          echo "additional-scripts=completed" >> $GITHUB_OUTPUT

      - name: ðŸ“¤ Upload Test Results & Coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_number }}
          path: |
            htmlcov/
            coverage.xml
            .coverage
            test-report.html
            test-report.json
            junit-report.xml
          retention-days: 30

  # License compliance check
  license-compliance:
    name: ðŸ“‹ License Compliance
    uses: bauer-group/automation-templates/.github/workflows/modules-license-compliance.yml@main
    with:
      fail-on-forbidden: false
      fail-on-unknown: false
      scan-dependencies: true
      generate-sbom: true
    secrets: inherit

  # Release management (BEFORE building final packages)
  release-management:
    name: ðŸš€ Release Management
    needs: [python-security-scan, python-build-test, license-compliance]
    uses: bauer-group/automation-templates/.github/workflows/modules-semantic-release.yml@main
    with:
      target-branch: "main"
      dry-run: false
    secrets: inherit

  # Python build with CORRECT version (AFTER semantic release)
  python-build-release:
    name: ðŸ§ª Python Build & Package (Release)
    if: needs.release-management.outputs.release-created == 'true' || inputs.force-release == true
    needs: [python-build-test, release-management]
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.version.outputs.version }}
      package-name: ${{ needs.python-build-test.outputs.package-name }}

    steps:
      - name: ðŸ“¥ Checkout Code (with updated version from semantic-release)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.release-management.outputs.tag-name }}

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version || '3.12' }}

      - name: ðŸ·ï¸ Get Updated Version
        id: version
        run: |
          VERSION="${{ needs.release-management.outputs.version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Final release version: $VERSION"

      - name: ðŸ“š Install Dependencies
        run: |
          python -m pip install --upgrade pip

          # Install based on available files
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          fi

          if [[ -f "requirements-dev.txt" ]]; then
            pip install -r requirements-dev.txt
          fi

          if [[ -f "dev-requirements.txt" ]]; then
            pip install -r dev-requirements.txt
          fi

          # Install package in development mode
          if [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
            pip install -e .
          fi

          # Install build tools
          pip install build twine

      - name: ðŸ“¦ Build Final Release Package
        run: |
          echo "ðŸ“¦ Building Python package with version ${{ steps.version.outputs.version }}..."
          python -m build

          echo "ðŸ” Checking package with twine..."
          twine check dist/*

      - name: ðŸ“¤ Upload Release Package Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-release-package-${{ github.run_number }}
          path: dist/
          retention-days: 30

  # PyPI Publishing
  publish-pypi:
    name: ðŸ“¦ Publish to PyPI
    if: (needs.release-management.outputs.release-created == 'true' || inputs.force-release == true) && inputs.skip-pypi != true
    needs: [python-build-release, release-management]
    runs-on: ubuntu-latest
    environment: pypi

    steps:
      - name: ðŸ“¥ Download Release Package
        uses: actions/download-artifact@v4
        with:
          name: python-release-package-${{ github.run_number }}
          path: dist/

      - name: ðŸš€ Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip-existing: true

      - name: ðŸ“Š Package Published
        run: |
          echo "ðŸŽ‰ Package published to PyPI!"
          echo "ðŸ“¦ Install with: pip install ${{ needs.python-build-release.outputs.package-name }}==${{ needs.python-build-release.outputs.version }}"

  # GitHub Repository Setup for Direct Installation
  setup-github-repo:
    name: ðŸ”§ Setup Repository for Direct Installation
    if: (needs.release-management.outputs.release-created == 'true' || inputs.force-release == true)
    needs: [python-build-release, release-management]
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.release-management.outputs.tag-name }}

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version || '3.12' }}

      - name: ðŸ”§ Verify Installation Compatibility
        run: |
          echo "ðŸ” Verifying repository structure for direct pip installation..."

          # Check for essential files
          if [[ -f "pyproject.toml" ]]; then
            echo "âœ… Found pyproject.toml - modern Python project structure (recommended)"
            echo "â„¹ï¸ No setup.py needed with pyproject.toml"
            cat pyproject.toml
          elif [[ -f "setup.py" ]]; then
            echo "âœ… Found setup.py - classic Python project structure"
            cat setup.py
          else
            echo "âŒ No pyproject.toml or setup.py found"
            echo "Creating minimal setup.py for direct installation..."
            cat > setup.py << 'EOF'
          from setuptools import setup, find_packages
          import os
          import re

          # Try to find version
          version = "0.1.0"
          init_files = []
          for root, dirs, files in os.walk("."):
              for file in files:
                  if file == "__init__.py":
                      init_files.append(os.path.join(root, file))

          for init_file in init_files:
              try:
                  with open(init_file, "r") as f:
                      content = f.read()
                  match = re.search(r"__version__\s*=\s*['\"]([^'\"]+)['\"]", content)
                  if match:
                      version = match.group(1)
                      break
              except:
                  continue

          setup(
              name=os.path.basename(os.getcwd()),
              version=version,
              packages=find_packages(),
              install_requires=[],
              python_requires=">=3.8",
          )
          EOF
          fi

          # Verify package structure
          echo "ðŸ“¦ Package structure:"
          find . -name "*.py" -path "*/src/*" -o -name "*.py" -path "*/lib/*" -o -name "setup.py" -o -name "pyproject.toml" | head -10

          # Test installation compatibility
          echo "ðŸ§ª Testing direct installation compatibility..."
          python -m pip install --upgrade pip setuptools wheel

          # Try installation in dry-run mode
          if [[ -f "pyproject.toml" ]]; then
            python -m pip install --dry-run -e . || echo "âš ï¸ Installation may have issues"
          elif [[ -f "setup.py" ]]; then
            python setup.py check || echo "âš ï¸ Setup.py may have issues"
          fi

      - name: ðŸ“‹ Generate Installation Instructions
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ“¦ Direct Git Installation Ready

          **Install Latest Release:**
          \`\`\`bash
          pip install git+https://github.com/${{ github.repository }}@${{ needs.release-management.outputs.tag-name }}
          \`\`\`

          **Install from Main Branch:**
          \`\`\`bash
          pip install git+https://github.com/${{ github.repository }}
          \`\`\`

          **Install Specific Version:**
          \`\`\`bash
          pip install git+https://github.com/${{ github.repository }}@v${{ needs.python-build-release.outputs.version }}
          \`\`\`

          **Development Installation (Editable):**
          \`\`\`bash
          git clone https://github.com/${{ github.repository }}.git
          cd $(basename ${{ github.repository }})
          pip install -e .
          \`\`\`

          ---
          *Repository configured for direct pip installation* âœ…
          EOF

      - name: ðŸ“ Create Installation Guide
        run: |
          cat > INSTALLATION.MD << 'EOF'
          # Installation Guide

          ## Direct Installation from GitHub

          ### Latest Release (Recommended)
          ```bash
          pip install git+https://github.com/${{ github.repository }}@${{ needs.release-management.outputs.tag-name }}
          ```

          ### Development Version
          ```bash
          pip install git+https://github.com/${{ github.repository }}
          ```

          ### Specific Version
          ```bash
          pip install git+https://github.com/${{ github.repository }}@v${{ needs.python-build-release.outputs.version }}
          ```

          ### With Specific Dependencies
          ```bash
          pip install "git+https://github.com/${{ github.repository }}[dev]"
          ```

          ### Development Installation
          For contributing or local development:
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd $(basename ${{ github.repository }})
          pip install -e ".[dev]"
          ```

          ## Requirements
          - Python >= 3.8
          - Git installed on your system
          - Internet connection

          ## Troubleshooting

          ### Authentication Issues (Private Repos)
          ```bash
          pip install git+https://username:token@github.com/${{ github.repository }}.git
          ```

          ### SSL Certificate Issues
          ```bash
          pip install --trusted-host github.com git+https://github.com/${{ github.repository }}
          ```

          ### Upgrade Installation
          ```bash
          pip install --upgrade git+https://github.com/${{ github.repository }}
          ```

          ## PyPI Installation (if available)
          ```bash
          pip install ${{ needs.python-build-release.outputs.package-name }}
          ```

          ---
          Generated by: ${{ github.workflow }} on ${{ github.run_id }}
          EOF

          echo "ðŸ“ Created INSTALLATION.MD guide"

      - name: ðŸ’¾ Commit Installation Guide
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [[ -n $(git status --porcelain) ]]; then
            git add INSTALLATION.MD || true
            git commit -m "docs: add installation guide for release ${{ needs.release-management.outputs.tag-name }}" || true
            git push origin ${{ needs.release-management.outputs.tag-name }} || true
          else
            echo "â„¹ï¸ No changes to commit"
          fi

  # Pipeline summary
  pipeline-summary:
    name: ðŸ“Š Pipeline Summary
    if: always()
    needs:
      [
        python-security-scan,
        python-build-test,
        license-compliance,
        release-management,
        python-build-release,
        publish-pypi,
        setup-github-repo,
      ]
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“Š Generate Pipeline Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ Python Automatic Release Summary

          ## ðŸ“¦ Package Information
          - **Name:** ${{ needs.python-build-test.outputs.package-name || 'N/A' }}
          - **Version:** ${{ needs.python-build-release.outputs.version || needs.release-management.outputs.version || 'N/A' }}
          - **Event:** ${{ github.event_name }}
          - **Branch:** ${{ github.ref_name }}
          - **Python Version:** ${{ inputs.python-version || '3.12' }}

          ## ðŸ” Pipeline Results
          | Component | Status | Details |
          |-----------|--------|---------|
          | **ðŸ›¡ï¸ Security Scan** | ${{ needs.python-security-scan.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} | Python security tools + ${{ inputs.security-engine || 'both' }} |
          | **ðŸ§ª Build & Test** | ${{ needs.python-build-test.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} | Custom + Standard tests |
          | **ðŸ“‹ License Compliance** | ${{ needs.license-compliance.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} | SBOM generated |
          | **ðŸš€ Release Management** | ${{ needs.release-management.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} | Release: ${{ needs.release-management.outputs.release-created || 'false' }} |
          | **ðŸ§ª Release Build** | ${{ needs.python-build-release.result == 'success' && 'âœ… PASS' || needs.python-build-release.result == 'skipped' && 'â­ï¸ SKIP' || 'âŒ FAIL' }} | With correct version |
          | **ðŸ“¦ PyPI Publishing** | ${{ needs.publish-pypi.result == 'success' && 'âœ… PUBLISHED' || needs.publish-pypi.result == 'skipped' && 'â­ï¸ SKIP' || 'âŒ FAIL' }} | PyPI package |
          | **ðŸ”§ GitHub Direct Install** | ${{ needs.setup-github-repo.result == 'success' && 'âœ… READY' || needs.setup-github-repo.result == 'skipped' && 'â­ï¸ SKIP' || 'âŒ FAIL' }} | Git installation ready |

          ## ðŸ“¤ Generated Artifacts
          - **Test Results:** test-results-${{ github.run_number }}
          - **Security Reports:** python-security-reports-${{ github.run_number }}
          - **Release Package:** python-release-package-${{ github.run_number }}

          EOF

          if [[ "${{ needs.release-management.outputs.release-created }}" == "true" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸŽ‰ Release Created Successfully!

          **Installation:**
          \`\`\`bash
          pip install ${{ needs.python-build-test.outputs.package-name }}==${{ needs.python-build-release.outputs.version }}
          \`\`\`

          **Release:** [View on GitHub](https://github.com/${{ github.repository }}/releases/tag/${{ needs.release-management.outputs.tag-name }})

          EOF
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ---
          *Powered by **BAUER GROUP** Python automation* ðŸ
          EOF

  # Documentation Update (matches automatic-release.yml pattern)
  update-documentation:
    name: ðŸ“„ Update Documentation
    if: needs.release-management.outputs.release-created == 'true'
    needs: [release-management, setup-github-repo]
    uses: bauer-group/automation-templates/.github/workflows/documentation.yml@main
    with:
      tag-name: ${{ needs.release-management.outputs.tag-name }}
      force-update: true
    permissions:
      contents: write
      pull-requests: write

  # Security Management Update (matches automatic-release.yml pattern)
  update-security-management:
    name: ðŸ›¡ï¸ Update Security Management
    if: needs.release-management.outputs.release-created == 'true'
    needs: [release-management, setup-github-repo]
    uses: bauer-group/automation-templates/.github/workflows/security-management.yml@main
    with:
      tag-name: ${{ needs.release-management.outputs.tag-name }}
      force-update: true
    permissions:
      contents: write
      pull-requests: write
