name: ğŸš€ Enhanced Release Management

on:
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Type of release'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - patch
          - minor
          - major
      force-release:
        description: 'Force a release even without conventional commits'
        required: false
        default: false
        type: boolean
      artifact-types:
        description: 'Types of artifacts to generate'
        required: false
        default: 'none'
        type: choice
        options:
          - none
          - binaries
          - docker
          - all
      cleanup-branches:
        description: 'Clean up release branches after success'
        required: false
        default: true
        type: boolean
  push:
    branches:
      - main
      - master
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    types: [closed]
    branches:
      - main
      - master

env:
  # Release Configuration
  RELEASE_TYPE: ${{ inputs.release-type || 'standard' }}
  FORCE_RELEASE: ${{ inputs.force-release || 'false' }}
  
  # Feature Toggles
  ENABLE_SECURITY_SCAN: true
  ENABLE_LICENSE_CHECK: true
  ENABLE_ARTIFACTS: ${{ inputs.artifact-types != 'none' }}
  ENABLE_AUTO_MERGE: false
  
  # Cleanup Configuration  
  CLEANUP_RELEASE_BRANCH: ${{ inputs.cleanup-branches != false }}
  
  # GitHub Configuration
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release-management:
    name: ğŸ¯ Release Management
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      release_created: ${{ steps.enhanced-release.outputs.release_created || steps.universal_fallback.outputs.release_created }}
      tag_name: ${{ steps.enhanced-release.outputs.tag_name || steps.universal_fallback.outputs.tag_name }}
      version: ${{ steps.enhanced-release.outputs.version || steps.universal_fallback.outputs.version }}
      html_url: ${{ steps.enhanced-release.outputs.html_url || steps.universal_fallback.outputs.release_url }}
      pr_number: ${{ steps.enhanced-release.outputs.pr_number }}
      pr_merged: ${{ steps.enhanced-release.outputs.pr_merged }}
      security_score: ${{ steps.enhanced-release.outputs.security_score }}
      license_compliance: ${{ steps.enhanced-release.outputs.license_compliance }}
      artifacts_generated: ${{ steps.enhanced-release.outputs.artifacts_generated }}

    steps:
      - name: ğŸ”„ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ¯ Enhanced Release Please
        id: enhanced-release
        uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: .github/config/.release-please-config.json
          manifest-file: .github/config/.release-please-manifest.json

      - name: ğŸ”„ Universal Fallback Release
        id: universal_fallback
        if: |
          steps.enhanced-release.outputs.release_created != 'true' &&
          (env.FORCE_RELEASE == 'true' || inputs.force-release == true)
        shell: bash
        run: |
          echo "ğŸ”„ Release-Please created no release, running Universal Fallback..."
          
          # Make script executable
          chmod +x scripts/universal-release.sh
          
          # Run universal release script
          ./scripts/universal-release.sh

      - name: ğŸ—‘ï¸ Cleanup Release Branches
        if: |
          (steps.enhanced-release.outputs.release_created == 'true' || 
           steps.universal_fallback.outputs.release_created == 'true') &&
          env.CLEANUP_RELEASE_BRANCH == 'true'
        shell: bash
        run: |
          echo "ğŸ—‘ï¸ Cleaning up release branches..."
          
          # Find and delete release-please branches
          RELEASE_BRANCHES=$(git ls-remote --heads origin | grep 'release-please' | awk '{print $2}' | sed 's|refs/heads/||' || true)
          
          if [ -n "$RELEASE_BRANCHES" ]; then
            echo "Found release branches to clean up:"
            echo "$RELEASE_BRANCHES"
            
            for branch in $RELEASE_BRANCHES; do
              echo "Deleting branch: $branch"
              git push origin --delete "$branch" || echo "Failed to delete $branch (may not exist)"
            done
          else
            echo "No release-please branches found to clean up"
          fi

      - name: ğŸ“Š Generate Release Dashboard
        uses: actions/github-script@v7
        with:
          script: |
            const releaseCreated = '${{ steps.enhanced-release.outputs.release_created }}';
            const fallbackReleaseCreated = '${{ steps.universal_fallback.outputs.release_created }}';
            const tagName = '${{ steps.enhanced-release.outputs.tag_name }}' || '${{ steps.universal_fallback.outputs.tag_name }}';
            const version = '${{ steps.enhanced-release.outputs.version }}' || '${{ steps.universal_fallback.outputs.version }}';
            const htmlUrl = '${{ steps.enhanced-release.outputs.html_url }}' || '${{ steps.universal_fallback.outputs.release_url }}';
            const prNumber = '${{ steps.enhanced-release.outputs.pr_number }}';
            const prMerged = '${{ steps.enhanced-release.outputs.pr_merged }}';
            const securityScore = '${{ steps.enhanced-release.outputs.security_score }}';
            const licenseCompliance = '${{ steps.enhanced-release.outputs.license_compliance }}';
            const artifactsGenerated = '${{ steps.enhanced-release.outputs.artifacts_generated }}';
            
            const anyReleaseCreated = releaseCreated === 'true' || fallbackReleaseCreated === 'true';
            const releaseMethod = releaseCreated === 'true' ? 'Enhanced Release Please' : 
                                 fallbackReleaseCreated === 'true' ? 'Universal Fallback' : 'None';
            
            let summary = [
              '### ğŸš€ Enhanced Release Management Dashboard',
              '',
              '| Component | Status | Details |',
              '|-----------|--------|---------|',
              '| **Event** | ğŸ“‹ | ${{ github.event_name }} |',
              '| **Branch** | ğŸŒ¿ | ${{ github.ref_name }} |',
              '| **Release Type** | ğŸ“¦ | ${{ env.RELEASE_TYPE }} |',
              '| **Force Release** | âš¡ | ${{ inputs.force-release || 'false' }} |',
              '| **Release Method** | ğŸ”§ | ' + releaseMethod + ' |',
              '',
              '#### ğŸ”§ Features Status',
              '| Feature | Enabled | Result |',
              '|---------|---------|--------|',
              '| Security Scan | ${{ env.ENABLE_SECURITY_SCAN }} | ' + (securityScore || 'N/A') + ' |',
              '| License Check | ${{ env.ENABLE_LICENSE_CHECK }} | ' + (licenseCompliance || 'N/A') + ' |',
              '| Artifact Generation | ${{ env.ENABLE_ARTIFACTS }} | ' + (artifactsGenerated || 'N/A') + ' |',
              '| Auto Merge PR | ${{ env.ENABLE_AUTO_MERGE }} | ' + (prMerged || 'N/A') + ' |',
              '| Branch Cleanup | ${{ env.CLEANUP_RELEASE_BRANCH }} | ' + (anyReleaseCreated ? 'âœ… Executed' : 'N/A') + ' |',
              '',
              '#### ğŸ“‹ Release Results',
              '| Field | Value |',
              '|-------|-------|',
              '| **Release Method** | ' + releaseMethod + ' |',
              '| **Release Created** | ' + (anyReleaseCreated ? 'true' : 'false') + ' |'
            ];
            
            if (releaseCreated === 'true') {
              summary.push(
                '| **Tag Name** | `' + tagName + '` |',
                '| **Version** | `' + version + '` |',
                '| **Release URL** | [View Release](' + htmlUrl + ') |'
              );
            } else if (fallbackReleaseCreated === 'true') {
              summary.push(
                '| **Tag Name** | `' + tagName + '` |',
                '| **Version** | `' + version + '` |',
                '| **Release URL** | [View Release](' + htmlUrl + ') |'
              );
            } else if (prNumber) {
              summary.push(
                '| **PR Number** | [#' + prNumber + '](https://github.com/${{ github.repository }}/pull/' + prNumber + ') |',
                '| **PR Status** | ' + (prMerged === 'true' ? 'Merged' : 'Open') + ' |'
              );
            }
            
            summary.push('');
            
            if (releaseCreated === 'true') {
              summary.push(
                'ğŸ‰ **Release Successfully Created!**',
                '',
                '**Next Steps:**',
                '- âœ… Release notes generated automatically',
                '- âœ… GitHub release is available',
                '- âœ… Tags are ready for external consumption'
              );
              
              if ('${{ env.ENABLE_ARTIFACTS }}' === 'true') {
                summary.push('- âœ… Release artifacts generated and uploaded');
              }
              
              if ('${{ env.ENABLE_SECURITY_SCAN }}' === 'true') {
                summary.push('- ğŸ›¡ï¸ Security scan completed (Score: ' + (securityScore || 'N/A') + '/100)');
              }
              
              if ('${{ env.ENABLE_LICENSE_CHECK }}' === 'true') {
                summary.push('- ğŸ“‹ License compliance verified (' + (licenseCompliance || 'N/A') + ')');
              }
              
            } else if (fallbackReleaseCreated === 'true') {
              summary.push(
                'ğŸ‰ **Universal Fallback Release Created!**',
                '',
                '**Next Steps:**',
                '- âœ… Release created via universal script',
                '- âœ… GitHub release is available',
                '- âœ… Tags are ready for external consumption'
              );
            } else if (prNumber) {
              summary.push(
                'ğŸ“ **Release PR Created**',
                '',
                'A release PR has been created and is ready for review.',
                '',
                '**PR Actions:**'
              );
              
              if ('${{ env.ENABLE_AUTO_MERGE }}' === 'true') {
                if (prMerged === 'true') {
                  summary.push('- âœ… PR automatically merged');
                } else {
                  summary.push('- â³ Auto-merge attempted but manual review required');
                }
              } else {
                summary.push('- ğŸ‘¥ Manual review and merge required');
              }
            } else {
              summary.push(
                'â„¹ï¸ **No Release Action Taken**',
                '',
                '**Possible Reasons:**',
                '- No conventional commits since last release',
                '- Only non-releasable changes (docs, chore, etc.)',
                '- Release-Please PR already exists'
              );
            }
            
            await core.summary.addRaw(summary.join('\n')).write();
            
            // Add release trigger help if no action taken
            if (!anyReleaseCreated && !prNumber) {
              const helpSummary = [
                '',
                '**To Trigger a Release:**',
                '- `feat:` for new features (minor version bump)',
                '- `fix:` for bug fixes (patch version bump)',
                '- `feat!:` or `BREAKING CHANGE:` for breaking changes (major version bump)'
              ];
              
              await core.summary.addRaw(helpSummary.join('\n')).write();
            }

  # Extended artifact generation for specific types
  extended-artifacts:
    name: ğŸ”¨ Extended Artifact Generation
    if: |
      needs.release-management.outputs.release_created == 'true' && 
      (github.event_name == 'workflow_dispatch' && 
       (inputs.artifact-types == 'binaries' || inputs.artifact-types == 'docker' || inputs.artifact-types == 'all'))
    needs: release-management
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - artifact: binaries
            enabled: ${{ inputs.artifact-types == 'binaries' || inputs.artifact-types == 'all' }}
          - artifact: docker
            enabled: ${{ inputs.artifact-types == 'docker' || inputs.artifact-types == 'all' }}
    
    steps:
      - name: ğŸ”„ Checkout Repository
        if: matrix.enabled
        uses: actions/checkout@v4

      - name: ğŸ”¨ Generate Binary Artifacts
        if: matrix.artifact == 'binaries' && matrix.enabled
        run: |
          echo "ğŸ”¨ Generating binary artifacts for release ${{ needs.release-management.outputs.tag_name }}"
          mkdir -p artifacts/binaries
          echo "Binary artifact placeholder" > artifacts/binaries/release-${{ needs.release-management.outputs.version }}.bin

      - name: ğŸ³ Build Docker Images
        if: matrix.artifact == 'docker' && matrix.enabled
        run: |
          echo "ğŸ³ Building Docker images for release ${{ needs.release-management.outputs.tag_name }}"
          echo "Docker build would happen here"

      - name: ğŸ“¦ Upload Artifacts
        if: matrix.enabled
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}-artifacts
          path: artifacts/
          retention-days: 30
