name: 'Python Package Build & Publish'
description: 'Build and publish Python packages to PyPI/TestPyPI with validation and security checks'
author: 'BAUER GROUP'

inputs:
  working-directory:
    description: 'Working directory for all commands'
    required: false
    default: '.'
  # Package Configuration
  package-version:
    description: 'Package version (auto-detected if not provided)'
    required: false
    default: ''
  package-name:
    description: 'Package name (auto-detected if not provided)'
    required: false
    default: ''
  # Build Configuration
  build-backend:
    description: 'Build backend (setuptools, poetry, hatch, flit)'
    required: false
    default: 'auto'
  build-formats:
    description: 'Build formats (wheel, sdist, both)'
    required: false
    default: 'both'
  include-source:
    description: 'Include source code in package'
    required: false
    default: 'false'
  include-symbols:
    description: 'Include debug symbols'
    required: false
    default: 'false'
  # Validation
  validate-package:
    description: 'Validate package with twine check'
    required: false
    default: 'true'
  run-tests:
    description: 'Run tests before building'
    required: false
    default: 'true'
  test-command:
    description: 'Custom test command'
    required: false
    default: 'pytest'
  # Publishing Configuration
  publish-to:
    description: 'Where to publish (none, testpypi, pypi, both)'
    required: false
    default: 'none'
  testpypi-repository:
    description: 'TestPyPI repository URL'
    required: false
    default: 'https://test.pypi.org/legacy/'
  pypi-repository:
    description: 'PyPI repository URL'
    required: false
    default: 'https://upload.pypi.org/legacy/'
  skip-existing:
    description: 'Skip uploading if package version already exists'
    required: false
    default: 'true'
  # Security & Verification
  verify-signature:
    description: 'Verify package signature before publishing'
    required: false
    default: 'false'
  sign-package:
    description: 'Sign package with GPG'
    required: false
    default: 'false'
  # Metadata
  update-changelog:
    description: 'Update changelog automatically'
    required: false
    default: 'false'
  generate-docs:
    description: 'Generate documentation'
    required: false
    default: 'false'
  # Environment
  python-version:
    description: 'Python version for building'
    required: false
    default: '3.12'

outputs:
  package-version:
    description: 'Built package version'
    value: ${{ steps.package-info.outputs.version }}
  package-name:
    description: 'Built package name'
    value: ${{ steps.package-info.outputs.name }}
  wheel-path:
    description: 'Path to built wheel file'
    value: ${{ steps.build.outputs.wheel-path }}
  sdist-path:
    description: 'Path to built source distribution'
    value: ${{ steps.build.outputs.sdist-path }}
  package-size:
    description: 'Package size in bytes'
    value: ${{ steps.package-info.outputs.size }}
  published-to:
    description: 'Where the package was published'
    value: ${{ steps.publish.outputs.published-to }}
  pypi-url:
    description: 'PyPI package URL'
    value: ${{ steps.publish.outputs.pypi-url }}
  testpypi-url:
    description: 'TestPyPI package URL'
    value: ${{ steps.publish.outputs.testpypi-url }}

runs:
  using: 'composite'
  steps:
    - name: ðŸ” Detect Package Information
      id: package-info
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ” Detecting package information..."
        
        PACKAGE_NAME="${{ inputs.package-name }}"
        PACKAGE_VERSION="${{ inputs.package-version }}"
        BUILD_BACKEND="${{ inputs.build-backend }}"
        
        # Auto-detect build backend
        if [ "$BUILD_BACKEND" = "auto" ]; then
          if [ -f "pyproject.toml" ] && grep -q "poetry" pyproject.toml 2>/dev/null; then
            BUILD_BACKEND="poetry"
          elif [ -f "pyproject.toml" ] && grep -q "hatchling" pyproject.toml 2>/dev/null; then
            BUILD_BACKEND="hatch"
          elif [ -f "pyproject.toml" ] && grep -q "flit" pyproject.toml 2>/dev/null; then
            BUILD_BACKEND="flit"
          elif [ -f "setup.py" ] || [ -f "setup.cfg" ]; then
            BUILD_BACKEND="setuptools"
          else
            BUILD_BACKEND="setuptools"
          fi
        fi
        
        # Auto-detect package name and version
        if [ -z "$PACKAGE_NAME" ] || [ -z "$PACKAGE_VERSION" ]; then
          if [ "$BUILD_BACKEND" = "poetry" ] && [ -f "pyproject.toml" ]; then
            # Extract from Poetry pyproject.toml
            if command -v python3 >/dev/null 2>&1; then
              INFO=$(python3 -c "
import tomllib
try:
    with open('pyproject.toml', 'rb') as f:
        data = tomllib.load(f)
    project = data.get('tool', {}).get('poetry', {})
    name = project.get('name', '')
    version = project.get('version', '')
    print(f'{name},{version}')
except:
    print(',')
" 2>/dev/null || echo ",")
              IFS=',' read -r AUTO_NAME AUTO_VERSION <<< "$INFO"
              if [ -z "$PACKAGE_NAME" ]; then PACKAGE_NAME="$AUTO_NAME"; fi
              if [ -z "$PACKAGE_VERSION" ]; then PACKAGE_VERSION="$AUTO_VERSION"; fi
            fi
          elif [ -f "pyproject.toml" ]; then
            # Extract from standard pyproject.toml
            if command -v python3 >/dev/null 2>&1; then
              INFO=$(python3 -c "
import tomllib
try:
    with open('pyproject.toml', 'rb') as f:
        data = tomllib.load(f)
    project = data.get('project', {})
    name = project.get('name', '')
    version = project.get('version', '')
    print(f'{name},{version}')
except:
    print(',')
" 2>/dev/null || echo ",")
              IFS=',' read -r AUTO_NAME AUTO_VERSION <<< "$INFO"
              if [ -z "$PACKAGE_NAME" ]; then PACKAGE_NAME="$AUTO_NAME"; fi
              if [ -z "$PACKAGE_VERSION" ]; then PACKAGE_VERSION="$AUTO_VERSION"; fi
            fi
          elif [ -f "setup.py" ]; then
            # Extract from setup.py
            if [ -z "$PACKAGE_NAME" ]; then
              PACKAGE_NAME=$(python3 setup.py --name 2>/dev/null || echo "")
            fi
            if [ -z "$PACKAGE_VERSION" ]; then
              PACKAGE_VERSION=$(python3 setup.py --version 2>/dev/null || echo "")
            fi
          fi
        fi
        
        # Fallback values
        if [ -z "$PACKAGE_NAME" ]; then
          PACKAGE_NAME=$(basename "$(pwd)")
        fi
        if [ -z "$PACKAGE_VERSION" ]; then
          PACKAGE_VERSION="0.1.0-dev.${{ github.run_number }}"
        fi
        
        echo "name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
        echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
        echo "build-backend=$BUILD_BACKEND" >> $GITHUB_OUTPUT
        
        echo "ðŸ“¦ Package Information:"
        echo "  â€¢ Name: $PACKAGE_NAME"
        echo "  â€¢ Version: $PACKAGE_VERSION"
        echo "  â€¢ Build Backend: $BUILD_BACKEND"

    - name: ðŸ”§ Setup Build Environment
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ”§ Setting up build environment..."
        
        BUILD_BACKEND="${{ steps.package-info.outputs.build-backend }}"
        
        case "$BUILD_BACKEND" in
          poetry)
            if ! command -v poetry &> /dev/null; then
              echo "Installing Poetry..."
              curl -sSL https://install.python-poetry.org | python3 -
              echo "$HOME/.local/bin" >> $GITHUB_PATH
            fi
            ;;
          setuptools)
            echo "Installing build tools..."
            pip install build twine wheel setuptools
            ;;
          hatch)
            echo "Installing Hatch..."
            pip install hatch
            ;;
          flit)
            echo "Installing Flit..."
            pip install flit
            ;;
        esac
        
        # Always install twine for validation and publishing
        pip install twine

    - name: ðŸ§ª Run Tests
      if: inputs.run-tests == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ§ª Running tests before building..."
        
        BUILD_BACKEND="${{ steps.package-info.outputs.build-backend }}"
        
        if [ -n "${{ inputs.test-command }}" ]; then
          ${{ inputs.test-command }}
        else
          case "$BUILD_BACKEND" in
            poetry)
              if poetry run which pytest >/dev/null 2>&1; then
                poetry run pytest
              else
                poetry run python -m unittest discover
              fi
              ;;
            *)
              if command -v pytest >/dev/null 2>&1; then
                pytest
              else
                python -m unittest discover
              fi
              ;;
          esac
        fi

    - name: ðŸ“¦ Build Package
      id: build
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ“¦ Building package..."
        
        BUILD_BACKEND="${{ steps.package-info.outputs.build-backend }}"
        BUILD_FORMATS="${{ inputs.build-formats }}"
        PACKAGE_NAME="${{ steps.package-info.outputs.name }}"
        PACKAGE_VERSION="${{ steps.package-info.outputs.version }}"
        
        # Create dist directory
        mkdir -p dist
        rm -rf dist/*
        
        case "$BUILD_BACKEND" in
          poetry)
            echo "Building with Poetry..."
            poetry build
            ;;
            
          hatch)
            echo "Building with Hatch..."
            hatch build
            ;;
            
          flit)
            echo "Building with Flit..."
            case "$BUILD_FORMATS" in
              wheel) flit build --format wheel ;;
              sdist) flit build --format sdist ;;
              both) flit build ;;
            esac
            ;;
            
          setuptools)
            echo "Building with setuptools..."
            case "$BUILD_FORMATS" in
              wheel) python -m build --wheel ;;
              sdist) python -m build --sdist ;;
              both) python -m build ;;
            esac
            ;;
        esac
        
        # Find built files
        WHEEL_PATH=""
        SDIST_PATH=""
        
        if [ "$BUILD_FORMATS" = "wheel" ] || [ "$BUILD_FORMATS" = "both" ]; then
          WHEEL_PATH=$(find dist -name "*.whl" -type f | head -1)
          if [ -n "$WHEEL_PATH" ]; then
            echo "ðŸ“¦ Wheel built: $WHEEL_PATH"
          fi
        fi
        
        if [ "$BUILD_FORMATS" = "sdist" ] || [ "$BUILD_FORMATS" = "both" ]; then
          SDIST_PATH=$(find dist -name "*.tar.gz" -type f | head -1)
          if [ -n "$SDIST_PATH" ]; then
            echo "ðŸ“¦ Source distribution built: $SDIST_PATH"
          fi
        fi
        
        # Calculate total package size
        TOTAL_SIZE=0
        for file in dist/*; do
          if [ -f "$file" ]; then
            SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
          fi
        done
        
        echo "wheel-path=$WHEEL_PATH" >> $GITHUB_OUTPUT
        echo "sdist-path=$SDIST_PATH" >> $GITHUB_OUTPUT
        
        # Update package info with size
        echo "size=$TOTAL_SIZE" >> $GITHUB_OUTPUT
        
        echo "ðŸ“¦ Build completed:"
        echo "  â€¢ Total package size: $TOTAL_SIZE bytes"
        ls -la dist/

    - name: âœ… Validate Package
      if: inputs.validate-package == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "âœ… Validating package with twine..."
        
        if twine check dist/*; then
          echo "âœ… Package validation passed"
        else
          echo "âŒ Package validation failed"
          exit 1
        fi
        
        # Additional checks
        echo "ðŸ” Additional package checks..."
        
        # Check for required metadata
        if [ -n "${{ steps.build.outputs.wheel-path }}" ]; then
          WHEEL_PATH="${{ steps.build.outputs.wheel-path }}"
          echo "Checking wheel metadata..."
          python -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('$WHEEL_PATH', 'r') as z:
        metadata_files = [f for f in z.namelist() if f.endswith('METADATA')]
        if metadata_files:
            metadata = z.read(metadata_files[0]).decode('utf-8')
            required_fields = ['Name:', 'Version:', 'Summary:']
            for field in required_fields:
                if field not in metadata:
                    print(f'Warning: Missing {field} in metadata')
        else:
            print('Warning: No metadata file found in wheel')
except Exception as e:
    print(f'Error checking wheel: {e}')
"
        fi

    - name: ðŸ” Sign Package
      if: inputs.sign-package == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ” Signing package with GPG..."
        
        for file in dist/*; do
          if [ -f "$file" ]; then
            echo "Signing $file..."
            gpg --detach-sign --armor "$file"
          fi
        done

    - name: ðŸ“Š Generate Package Report
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ“Š Generating package report..."
        
        PACKAGE_NAME="${{ steps.package-info.outputs.name }}"
        PACKAGE_VERSION="${{ steps.package-info.outputs.version }}"
        PACKAGE_SIZE="${{ steps.package-info.outputs.size }}"
        
        mkdir -p package-reports
        
        cat > package-reports/package-info.json << EOF
{
  "name": "$PACKAGE_NAME",
  "version": "$PACKAGE_VERSION",
  "size": $PACKAGE_SIZE,
  "build_backend": "${{ steps.package-info.outputs.build-backend }}",
  "build_formats": "${{ inputs.build-formats }}",
  "files": [
EOF
        
        FIRST=true
        for file in dist/*; do
          if [ -f "$file" ]; then
            FILENAME=$(basename "$file")
            FILESIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              echo "," >> package-reports/package-info.json
            fi
            cat >> package-reports/package-info.json << EOF
    {
      "name": "$FILENAME",
      "size": $FILESIZE,
      "path": "$file"
    }
EOF
          fi
        done
        
        cat >> package-reports/package-info.json << EOF
  ]
}
EOF

    - name: ðŸš€ Publish Package
      id: publish
      if: inputs.publish-to != 'none'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸš€ Publishing package..."
        
        PUBLISH_TO="${{ inputs.publish-to }}"
        PACKAGE_NAME="${{ steps.package-info.outputs.name }}"
        PACKAGE_VERSION="${{ steps.package-info.outputs.version }}"
        PUBLISHED_TO=""
        PYPI_URL=""
        TESTPYPI_URL=""
        
        # Common twine arguments
        TWINE_ARGS=""
        if [ "${{ inputs.skip-existing }}" = "true" ]; then
          TWINE_ARGS="$TWINE_ARGS --skip-existing"
        fi
        
        case "$PUBLISH_TO" in
          testpypi|both)
            echo "ðŸ“¤ Publishing to TestPyPI..."
            if [ -n "${{ secrets.TEST_PYPI_API_TOKEN }}" ]; then
              twine upload \
                --repository-url ${{ inputs.testpypi-repository }} \
                --username __token__ \
                --password ${{ secrets.TEST_PYPI_API_TOKEN }} \
                $TWINE_ARGS \
                dist/*
              
              TESTPYPI_URL="https://test.pypi.org/project/$PACKAGE_NAME/$PACKAGE_VERSION/"
              PUBLISHED_TO="testpypi"
              echo "âœ… Published to TestPyPI: $TESTPYPI_URL"
            else
              echo "âŒ TEST_PYPI_API_TOKEN not provided"
              exit 1
            fi
            ;;
        esac
        
        case "$PUBLISH_TO" in
          pypi|both)
            echo "ðŸ“¤ Publishing to PyPI..."
            if [ -n "${{ secrets.PYPI_API_TOKEN }}" ]; then
              twine upload \
                --repository-url ${{ inputs.pypi-repository }} \
                --username __token__ \
                --password ${{ secrets.PYPI_API_TOKEN }} \
                $TWINE_ARGS \
                dist/*
              
              PYPI_URL="https://pypi.org/project/$PACKAGE_NAME/$PACKAGE_VERSION/"
              if [ "$PUBLISHED_TO" = "testpypi" ]; then
                PUBLISHED_TO="both"
              else
                PUBLISHED_TO="pypi"
              fi
              echo "âœ… Published to PyPI: $PYPI_URL"
            else
              echo "âŒ PYPI_API_TOKEN not provided"
              exit 1
            fi
            ;;
        esac
        
        echo "published-to=$PUBLISHED_TO" >> $GITHUB_OUTPUT
        echo "pypi-url=$PYPI_URL" >> $GITHUB_OUTPUT
        echo "testpypi-url=$TESTPYPI_URL" >> $GITHUB_OUTPUT

    - name: ðŸ“š Generate Documentation
      if: inputs.generate-docs == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      continue-on-error: true
      run: |
        echo "ðŸ“š Generating documentation..."
        
        # Install documentation tools
        pip install sphinx sphinx-rtd-theme || true
        
        # Generate basic documentation if not exists
        if [ ! -d "docs" ]; then
          mkdir -p docs
          sphinx-quickstart -q -p "${{ steps.package-info.outputs.name }}" \
            -a "GitHub Actions" \
            -v "${{ steps.package-info.outputs.version }}" \
            --ext-autodoc \
            --ext-viewcode \
            docs || true
        fi
        
        # Build documentation
        if [ -f "docs/conf.py" ]; then
          cd docs && make html && cd .. || true
        fi

    - name: ðŸ“¤ Upload Package Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: python-package-${{ steps.package-info.outputs.name }}-${{ steps.package-info.outputs.version }}
        path: |
          ${{ inputs.working-directory }}/dist/
          ${{ inputs.working-directory }}/package-reports/
        retention-days: 30

branding:
  icon: 'package'
  color: 'orange'