name: 'README Generator'
description: 'Professioneller README-Generator mit erweiterten Template-Features und Validierung'
author: 'BAUER GROUP'

inputs:
  template-path:
    description: 'Pfad zum README Template'
    required: false
    default: 'docs/README.template.MD'
  output-path:
    description: 'Pfad f√ºr generierte README'
    required: false
    default: 'README.MD'
  project-name:
    description: 'Name des Projekts'
    required: false
    default: ''
  company-name:
    description: 'Name der Firma'
    required: false
    default: 'BAUER GROUP'
  project-description:
    description: 'Projektbeschreibung'
    required: false
    default: ''
  contact-email:
    description: 'Kontakt E-Mail'
    required: false
    default: ''
  documentation-url:
    description: 'Dokumentations-URL'
    required: false
    default: ''
  support-url:
    description: 'Support-URL'
    required: false
    default: ''
  force-update:
    description: 'README auch ohne √Ñnderungen aktualisieren'
    required: false
    default: 'false'
  custom-version:
    description: 'Benutzerdefinierte Version (√ºberschreibt Git Tag)'
    required: false
    default: ''
  validate-output:
    description: 'Generierte README validieren'
    required: false
    default: 'true'

outputs:
  readme_updated:
    description: 'Ob README aktualisiert wurde'
    value: ${{ steps.commit.outputs.committed }}
  changes_detected:
    description: 'Ob √Ñnderungen erkannt wurden'
    value: ${{ steps.changes.outputs.changed }}
  validation_passed:
    description: 'Ob Validierung erfolgreich war'
    value: ${{ steps.validate.outputs.passed }}
  file_size:
    description: 'Gr√∂√üe der generierten README-Datei'
    value: ${{ steps.validate.outputs.file_size }}

runs:
  using: 'composite'
  steps:
    - name: üêç Setup Python Environment
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: üì¶ Install Dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip
        pip install requests gitpython python-dateutil

    - name: üîß Prepare Environment
      shell: bash
      run: |
        # Create backup of existing README if it exists
        if [ -f "${{ inputs.output-path }}" ]; then
          cp "${{ inputs.output-path }}" "${{ inputs.output-path }}.backup"
          echo "üìÑ Created backup: ${{ inputs.output-path }}.backup"
        fi
        
        # Set version from input or git tag
        if [ -n "${{ inputs.custom-version }}" ]; then
          echo "RELEASE_VERSION=${{ inputs.custom-version }}" >> $GITHUB_ENV
          echo "üè∑Ô∏è Using custom version: ${{ inputs.custom-version }}"
        else
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.1.0")
          echo "RELEASE_VERSION=${LATEST_TAG#v}" >> $GITHUB_ENV
          echo "üè∑Ô∏è Using git tag version: ${LATEST_TAG#v}"
        fi

    - name: üîÑ Download Latest Generator
      shell: bash
      run: |
        echo "üì• Downloading latest README generator..."
        if curl -fsSL --max-time 10 \
          "https://raw.githubusercontent.com/bauer-group/automation-templates/main/scripts/generate_readme.py" \
          -o generate_readme.py; then
          echo "‚úÖ Generator downloaded successfully"
          chmod +x generate_readme.py
        else
          echo "‚ö†Ô∏è Download failed, will use fallback generator"
        fi

    - name: üõ†Ô∏è Create Enhanced Fallback Generator
      shell: bash
      run: |
        if [ ! -f generate_readme.py ]; then
          echo "üîß Creating enhanced fallback generator..."
          cat > generate_readme.py << 'EOF'
        #!/usr/bin/env python3
        import os
        import re
        import json
        import subprocess
        from datetime import datetime, timezone
        from typing import Dict, Any
        
        def get_git_info() -> Dict[str, str]:
            """Get git repository information"""
            try:
                # Get remote URL
                remote_url = subprocess.check_output(
                    ["git", "config", "--get", "remote.origin.url"],
                    stderr=subprocess.STDOUT,
                ).decode().strip()
                
                # Parse GitHub URL
                if "github.com" in remote_url:
                    if remote_url.startswith("git@"):
                        match = re.search(r"github\.com:([^/]+)/(.+?)(?:\.git)?$", remote_url)
                    else:
                        match = re.search(r"github\.com/([^/]+)/(.+?)(?:\.git)?$", remote_url)
                    
                    if match:
                        owner, repo = match.groups()
                        return {
                            "REPO_OWNER": owner,
                            "REPO_NAME": repo,
                            "REPO_URL": f"https://github.com/{owner}/{repo}",
                            "REPO_FULL_NAME": f"{owner}/{repo}"
                        }
                
                # Get current branch
                current_branch = subprocess.check_output(
                    ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                    stderr=subprocess.STDOUT,
                ).decode().strip()
                
                return {
                    "REPO_OWNER": "unknown",
                    "REPO_NAME": "unknown", 
                    "REPO_URL": remote_url,
                    "REPO_FULL_NAME": "unknown/unknown",
                    "CURRENT_BRANCH": current_branch
                }
                
            except Exception as e:
                print(f"Warning: Could not get git info: {e}")
                return {
                    "REPO_OWNER": "unknown",
                    "REPO_NAME": "unknown",
                    "REPO_URL": "unknown",
                    "REPO_FULL_NAME": "unknown/unknown",
                    "CURRENT_BRANCH": "unknown"
                }
        
        def render_template(template: str, vars: dict) -> str:
            """Render template with variable substitution"""
            out = template
            
            # Simple variable substitution
            for k, v in vars.items():
                out = out.replace("{{" + k + "}}", str(v))
            
            return out
        
        def main():
            template_path = os.getenv('TEMPLATE_PATH', 'docs/README.template.MD')
            output_path = os.getenv('OUTPUT_PATH', 'README.MD')
            
            if not os.path.exists(template_path):
                print(f"‚ùå Template {template_path} not found")
                return 1
                
            with open(template_path, 'r', encoding='utf-8') as f:
                template = f.read()
            
            # Get current date and time
            now = datetime.now(timezone.utc)
            
            # Collect all variables
            variables = {
                "VERSION": os.getenv("RELEASE_VERSION", "0.1.0"),
                "DATE": now.strftime("%Y-%m-%d"),
                "DATETIME": now.strftime("%Y-%m-%d %H:%M:%S UTC"),
                "YEAR": now.strftime("%Y"),
                "PROJECT_NAME": os.getenv('PROJECT_NAME', ''),
                "COMPANY_NAME": os.getenv('COMPANY_NAME', 'BAUER GROUP'),
                "PROJECT_DESCRIPTION": os.getenv('PROJECT_DESCRIPTION', ''),
                "CONTACT_EMAIL": os.getenv('CONTACT_EMAIL', ''),
                "DOCUMENTATION_URL": os.getenv('DOCUMENTATION_URL', ''),
                "SUPPORT_URL": os.getenv('SUPPORT_URL', ''),
            }
            
            # Add git information
            variables.update(get_git_info())
            
            # Add GitHub Actions variables
            github_vars = ["GITHUB_REPOSITORY", "GITHUB_REPOSITORY_OWNER", "GITHUB_REF_NAME"]
            for var in github_vars:
                if os.getenv(var):
                    variables[var] = os.getenv(var)
            
            # Override with GitHub values if available
            if os.getenv("GITHUB_REPOSITORY"):
                variables["REPO_FULL_NAME"] = os.getenv("GITHUB_REPOSITORY")
                parts = os.getenv("GITHUB_REPOSITORY").split("/")
                if len(parts) == 2:
                    variables["REPO_OWNER"] = parts[0]
                    variables["REPO_NAME"] = parts[1]
                variables["REPO_URL"] = f"https://github.com/{os.getenv('GITHUB_REPOSITORY')}"
            
            if os.getenv("GITHUB_REF_NAME"):
                variables["CURRENT_BRANCH"] = os.getenv("GITHUB_REF_NAME")
            
            # Render template
            content = render_template(template, variables)
            
            # Write output with generation header
            banner = f"<!-- AUTO-GENERATED FILE. DO NOT EDIT. Edit {template_path} instead. -->\n"
            banner += f"<!-- Generated on {variables['DATETIME']} -->\n\n"
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(banner + content)
            
            print(f"‚úÖ README generated successfully: {output_path}")
            return 0
        
        if __name__ == '__main__':
            exit(main())
        EOF
        
          chmod +x generate_readme.py
          echo "‚úÖ Enhanced fallback generator created"
        fi

    - name: üìù Generate README
      shell: bash
      env:
        TEMPLATE_PATH: ${{ inputs.template-path }}
        OUTPUT_PATH: ${{ inputs.output-path }}
        PROJECT_NAME: ${{ inputs.project-name }}
        COMPANY_NAME: ${{ inputs.company-name }}
        PROJECT_DESCRIPTION: ${{ inputs.project-description }}
        CONTACT_EMAIL: ${{ inputs.contact-email }}
        DOCUMENTATION_URL: ${{ inputs.documentation-url }}
        SUPPORT_URL: ${{ inputs.support-url }}
      run: |
        echo "üîÑ Generating README..."
        echo "üìÑ Template: ${{ inputs.template-path }}"
        echo "üì§ Output: ${{ inputs.output-path }}"
        
        if python generate_readme.py; then
          echo "‚úÖ README generation completed"
        else
          echo "‚ùå README generation failed"
          exit 1
        fi

    - name: üîç Validate Generated README
      id: validate
      if: inputs.validate-output == 'true'
      shell: bash
      run: |
        README_FILE="${{ inputs.output-path }}"
        
        if [ ! -f "$README_FILE" ]; then
          echo "‚ùå Generated README not found"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Get file size
        FILE_SIZE=$(wc -c < "$README_FILE")
        echo "file_size=$FILE_SIZE" >> $GITHUB_OUTPUT
        
        # Validate file size
        if [ "$FILE_SIZE" -lt 100 ]; then
          echo "‚ùå Generated README is too small (${FILE_SIZE} bytes)"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Check for unresolved placeholders
        UNRESOLVED=$(grep -o "{{[^}]*}}" "$README_FILE" | wc -l || echo "0")
        
        if [ "$UNRESOLVED" -gt 0 ]; then
          echo "‚ö†Ô∏è Found $UNRESOLVED unresolved placeholders:"
          grep -o "{{[^}]*}}" "$README_FILE" | sort | uniq | head -5
        fi
        
        # Basic content validation
        if ! grep -q "^#" "$README_FILE"; then
          echo "‚ö†Ô∏è No main heading found"
        fi
        
        echo "‚úÖ README validation completed"
        echo "üìä File size: ${FILE_SIZE} bytes"
        echo "üîß Unresolved placeholders: $UNRESOLVED"
        echo "passed=true" >> $GITHUB_OUTPUT

    - name: üìä Check for Changes
      id: changes
      shell: bash
      run: |
        if [ "${{ inputs.force-update }}" = "true" ]; then
          echo "üîÑ Force update enabled - treating as changed"
          echo "changed=true" >> $GITHUB_OUTPUT
        elif git diff --quiet "${{ inputs.output-path }}"; then
          echo "‚ÑπÔ∏è No changes detected in README"
          echo "changed=false" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Changes detected in README"
          echo "changed=true" >> $GITHUB_OUTPUT
          
          # Show diff summary
          echo "üìã Change summary:"
          git diff --stat "${{ inputs.output-path }}" || true
        fi

    - name: üöÄ Commit Changes
      id: commit
      if: steps.changes.outputs.changed == 'true'
      shell: bash
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "üìÑ README Generator"
        
        if git add "${{ inputs.output-path }}" && git commit -m "docs: update ${{ inputs.output-path }} [skip ci]"; then
          echo "‚úÖ README changes committed"
          echo "committed=true" >> $GITHUB_OUTPUT
          
          # Clean up backup
          if [ -f "${{ inputs.output-path }}.backup" ]; then
            rm "${{ inputs.output-path }}.backup"
          fi
        else
          echo "‚ÑπÔ∏è No changes to commit"
          echo "committed=false" >> $GITHUB_OUTPUT
          
          # Restore backup if commit failed
          if [ -f "${{ inputs.output-path }}.backup" ]; then
            mv "${{ inputs.output-path }}.backup" "${{ inputs.output-path }}"
            echo "üîÑ Restored backup due to commit failure"
          fi
        fi

    - name: üßπ Cleanup
      if: always()
      shell: bash
      run: |
        # Clean up temporary files
        [ -f "generate_readme.py" ] && rm -f generate_readme.py
        [ -f "${{ inputs.output-path }}.backup" ] && rm -f "${{ inputs.output-path }}.backup"
        echo "üßπ Cleanup completed"

branding:
  icon: 'file-text'
  color: 'blue'
